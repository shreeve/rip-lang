{"pages/counter.rip":"# Counter Page\n\nexport Counter = component\n  count := 0\n  step := 1\n\n  increment: ->\n    count += step\n\n  decrement: ->\n    count -= step\n\n  reset: ->\n    count = 0\n\n  render\n    div\n      .page-header\n        h1.page-title \"Counter\"\n        p.page-subtitle \"Reactive state with := operator\"\n\n      .card\n        .counter-display \"#{count}\"\n\n        .counter-controls\n          button.btn @click: @decrement, \"- #{step}\"\n          button.btn @click: @reset, \"Reset\"\n          button.btn.btn-primary @click: @increment, \"+ #{step}\"\n\n      .card\n        .card-title \"Step Size\"\n        .btn-group\n          button.btn @click: (-> step = 1), \"1\"\n          button.btn @click: (-> step = 5), \"5\"\n          button.btn @click: (-> step = 10), \"10\"\n          button.btn @click: (-> step = 100), \"100\"\n","pages/index.rip":"# Home Page\n\nexport Home = component\n\n  render\n    div\n      .page-header\n        h1.page-title \"Rip UI Framework\"\n        p.page-subtitle \"Zero-build reactive web apps\"\n\n      .feature-grid\n        .feature-card\n          .feature-icon \"ðŸ—‚\"\n          .feature-name \"Virtual File System\"\n          .feature-desc \"Browser-local file storage. Components compiled on demand.\"\n\n        .feature-card\n          .feature-icon \"ðŸ”€\"\n          .feature-name \"File-Based Router\"\n          .feature-desc \"URLs map to VFS paths. Dynamic segments and nested layouts.\"\n\n        .feature-card\n          .feature-icon \"âš¡\"\n          .feature-name \"Reactive Stash\"\n          .feature-desc \"Deep state tree with path navigation. Every property tracked.\"\n\n        .feature-card\n          .feature-icon \"ðŸŽ¯\"\n          .feature-name \"Fine-Grained Rendering\"\n          .feature-desc \"No virtual DOM. Direct DOM updates via reactive effects.\"\n","pages/todos.rip":"# Todos Page\n\nexport Todos = component\n  newTodo := ''\n  todos := []\n  nextId := 1\n\n  remaining ~= todos.filter((t) -> not t.done).length\n\n  addTodo: ->\n    if newTodo.trim()\n      todos = [...todos, { id: nextId, text: newTodo.trim(), done: false }]\n      nextId++\n      newTodo = ''\n\n  deleteTodo: (id) ->\n    todos = todos.filter (t) -> t.id isnt id\n\n  clearAll: ->\n    todos = []\n\n  handleKey: (e) ->\n    if e.key is 'Enter'\n      @addTodo()\n\n  render\n    div\n      .page-header\n        h1.page-title \"Todos\"\n        p.page-subtitle \"List rendering and state management\"\n\n      .card\n        .todo-input-row\n          input.input type: \"text\", value: newTodo, placeholder: \"What needs to be done?\", @keydown: @handleKey\n          button.btn.btn-primary @click: @addTodo, \"Add\"\n\n        ul.todo-list\n          for todo in todos\n            li.todo-item\n              span.todo-text todo.text\n              button.todo-delete @click: (=> @deleteTodo(todo.id)), \"x\"\n\n        .todo-stats\n          span \"#{remaining} remaining\"\n          button.btn.btn-sm @click: @clearAll, \"Clear all\"\n","pages/about.rip":"# About Page\n\nexport About = component\n\n  render\n    div\n      .page-header\n        h1.page-title \"About Rip UI\"\n        p.page-subtitle \"Zero-build reactive web apps!\"\n\n      .card\n        h3 \"The Idea\"\n        p \"Traditional frameworks build and bundle on the server, then ship static artifacts. Rip UI ships the 40KB compiler to the browser instead. Components arrive as .rip source files, are compiled on demand, and render with fine-grained reactivity. No build step, no bundler, no configuration files.\"\n\n      .card\n        h3 \"Two Keywords\"\n        p \"The component model adds exactly two keywords to the Rip language: component and render. Everything else â€” reactive state (:=), computed values (~=), effects (~>), methods, lifecycle hooks â€” is standard Rip syntax that already exists.\"\n\n      .card\n        h3 \"Architecture\"\n        p \"The Virtual File System stores page components in memory. The Router maps URLs to VFS paths using file-based conventions (like Next.js). When you navigate, the Renderer compiles the matching .rip file and mounts the resulting component. Each reactive binding creates a direct DOM effect â€” no virtual DOM diffing.\"\n\n      .card\n        h3 \"Stack\"\n        .btn-group\n          .stat\n            span \"Compiler \"\n            span.stat-value \"40KB\"\n          .stat\n            span \"Framework \"\n            span.stat-value \"~8KB\"\n          .stat\n            span \"Build step \"\n            span.stat-value \"None\"\n          .stat\n            span \"Dependencies \"\n            span.stat-value \"Zero\"\n\n      .card\n        h3 \"Modules\"\n        p \"stash.js â€” Deep reactive state tree with path-based navigation. vfs.js â€” Browser-local Virtual File System with file watchers. router.js â€” File-based router mapping URLs to VFS paths. renderer.js â€” Compiles and mounts components, manages layouts and transitions. ui.js â€” createApp entry point that wires everything together.\"\n","pages/_layout.rip":"# Root Layout\n\nexport Layout = component\n\n  render\n    .app-layout\n      nav.app-nav\n        .nav-inner\n          a.nav-brand \"Rip UI\"\n          .nav-links\n            a.nav-link href: \"/\", \"Home\"\n            a.nav-link href: \"/counter\", \"Counter\"\n            a.nav-link href: \"/todos\", \"Todos\"\n            a.nav-link href: \"/about\", \"About\"\n      main.app-main\n        div data-slot: \"true\"\n"}