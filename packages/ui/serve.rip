# ==============================================================================
# @rip-lang/ui/serve — Rip UI Server Middleware
# ==============================================================================
#
# Serves the Rip UI runtime, auto-generated app bundles, and optional
# SSE hot-reload.
#
# Usage:
#   import { ripUI } from '@rip-lang/ui/serve'
#   use ripUI app: '/demo', dir: dir, title: 'My App'
#
# Options:
#   app:        string  — URL mount point (default: '')
#   dir:        string  — app directory on disk (default: '.')
#   components: string  — pages subdirectory name, relative to dir (default: 'components')
#   includes:   array   — shared component directories, relative to dir (merged as _lib/)
#   watch:      boolean — enable SSE hot-reload endpoint (default: false)
#   debounce:   number  — ms to batch filesystem events (default: 250)
#   state:      object  — initial app state passed via bundle
#   title:      string  — document title
#
# ==============================================================================

import { get } from '@rip-lang/api'
import { watch as fsWatch } from 'node:fs'

export ripUI = (opts = {}) ->
  prefix        = opts.app or ''
  appDir        = opts.dir or '.'
  componentsDir = "#{appDir}/#{opts.components or 'components'}"
  includeDirs   = (opts.includes or []).map (d) -> "#{appDir}/#{d}"
  enableWatch   = opts.watch or false
  debounceMs    = opts.debounce or 250
  appState      = opts.state or null
  appTitle      = opts.title or null
  uiDir         = import.meta.dir

  # Resolve rip-ui.min.js (compiler + UI framework bundled)
  bundlePath = null
  try
    bundlePath = Bun.fileURLToPath(import.meta.resolve('rip-lang/docs/dist/rip-ui.min.js'))
  catch
    bundlePath = "#{uiDir}/../../docs/dist/rip-ui.min.js"

  # ----------------------------------------------------------------------------
  # Route: /rip/* — framework files, registered once
  # ----------------------------------------------------------------------------

  unless ripUI._registered
    get "/rip/rip-ui.min.js", (c) -> c.send bundlePath, 'application/javascript'
    ripUI._registered = true

  # ----------------------------------------------------------------------------
  # Route: {prefix}/components/* — individual .rip component files (for hot-reload)
  # Route: {prefix}/bundle  — app bundle (components + data as JSON)
  # Route: {prefix}/watch   — SSE hot-reload stream
  # ----------------------------------------------------------------------------

  get "#{prefix}/components/*", (c) ->
    name = c.req.path.slice("#{prefix}/components/".length)
    c.send "#{componentsDir}/#{name}", 'text/plain; charset=UTF-8'

  bundleCache = null
  bundleDirty = true

  # Invalidate bundle cache when components change
  if enableWatch
    fsWatch componentsDir, { recursive: true }, (event, filename) ->
      bundleDirty = true if filename?.endsWith('.rip')
    for incDir in includeDirs
      fsWatch incDir, { recursive: true }, (event, filename) ->
        bundleDirty = true if filename?.endsWith('.rip')

  get "#{prefix}/bundle", (c) ->
    if bundleDirty or not bundleCache
      glob = new Bun.Glob("**/*.rip")
      components = {}
      paths = Array.from(glob.scanSync(componentsDir))
      for path in paths
        components["components/#{path}"] = Bun.file("#{componentsDir}/#{path}").text!

      # Merge external include directories into components/_lib/
      for dir in includeDirs
        incPaths = Array.from(glob.scanSync(dir))
        for path in incPaths
          key = "components/_lib/#{path}"
          components[key] = Bun.file("#{dir}/#{path}").text! unless components[key]

      data = {}
      data.title = appTitle if appTitle
      data.watch = enableWatch
      if appState
        data[k] = v for k, v of appState

      bundleCache = JSON.stringify({ components, data })
      bundleDirty = false

    new Response bundleCache, headers: { 'Content-Type': 'application/json' }

  if enableWatch
    get "#{prefix}/watch", (c) ->
      encoder = new TextEncoder()
      pending = new Set()
      timer    = null
      watcher  = null
      heartbeat = null

      watchers = []

      cleanup = ->
        w.close() for w in watchers
        clearTimeout(timer) if timer
        clearInterval(heartbeat) if heartbeat
        watchers = []
        heartbeat = timer = null

      new Response new ReadableStream(
        start: (controller) ->
          send = (event, data) ->
            try
              controller.enqueue encoder.encode("event: #{event}\ndata: #{JSON.stringify(data)}\n\n")
            catch
              cleanup()

          send 'connected', { time: Date.now() }

          heartbeat = setInterval ->
            try
              controller.enqueue encoder.encode(": heartbeat\n\n")
            catch
              cleanup()
          , 5000

          flush = ->
            paths = Array.from(pending)
            pending.clear()
            timer = null
            send('changed', { paths }) if paths.length > 0

          addWatcher = (dir, keyPrefix) ->
            watchers.push fsWatch dir, { recursive: true }, (event, filename) ->
              return unless filename?.endsWith('.rip')
              pending.add "#{keyPrefix}#{filename}"
              clearTimeout(timer) if timer
              timer = setTimeout(flush, debounceMs)

          addWatcher componentsDir, 'components/'
          for incDir in includeDirs
            addWatcher incDir, 'components/_lib/'

        cancel: -> cleanup()
      ),
        headers:
          'Content-Type': 'text/event-stream'
          'Cache-Control': 'no-cache'
          'Connection': 'keep-alive'

  # Return pass-through middleware
  (c, next) -> next!()
