#!/usr/bin/env rip

# ==============================================================================
# ORM Example — Schema-Driven Models with a Live Database
# ==============================================================================
#
# Demonstrates:
#   - Loading models from a .schema file (no manual schema declaration!)
#   - Schema-generated SQL DDL for table creation
#   - Class-based models with instance methods
#   - Computed properties (reactive)
#   - Query API (find, where, orderBy, limit, count)
#   - Relation loading (user.posts(), post.user())
#   - Eager loading (User.include('posts').all())
#   - Soft delete (softDelete, restore, withDeleted)
#   - Factory (schema-driven fake data generation)
#   - Dirty tracking and validation
#
# Prerequisites:
#   1. Install rip-db:  bun add -g @rip-lang/db
#   2. Start rip-db:    rip-db
#
# Run:
#   rip orm-example.rip
#
# ==============================================================================

import { Schema } from '../orm.js'

# ==============================================================================
# Load Schema — one .schema file drives everything
# ==============================================================================

schema = Schema.load './app.schema', import.meta.url
schema.connect 'http://localhost:4213'

# ==============================================================================
# Setup — Create tables from generated DDL
# ==============================================================================

exec = (sql) ->
  res = fetch! 'http://localhost:4213/sql',
    method: 'POST'
    headers: { 'Content-Type': 'application/json' }
    body: JSON.stringify { sql }
  data = res.json!
  throw new Error "SQL failed: #{data.error}" if data.error
  data

# Drop existing tables (reverse dependency order), then create from DDL
exec! """
  DROP TABLE IF EXISTS comments CASCADE;
  DROP TABLE IF EXISTS posts CASCADE;
  DROP TABLE IF EXISTS users CASCADE;
  DROP TABLE IF EXISTS organizations CASCADE;
  DROP TYPE IF EXISTS post_status CASCADE;
  DROP TYPE IF EXISTS role CASCADE;
"""

exec! schema.toSQL()

# Seed users, then posts (separate requests ensure users exist before FK lookup)
exec! """
  INSERT INTO users (name, email, role, bio, active) VALUES
    ('Alice',   'alice@example.com',   'admin',  'Platform administrator', true),
    ('Bob',     'bob@example.com',     'editor', 'Content editor', true),
    ('Charlie', 'charlie@example.com', 'viewer', NULL, true),
    ('Dana',    'dana@example.com',    'editor', 'Technical writer', false),
    ('Eve',     'eve@example.com',     'viewer', NULL, true);
"""

exec! """
  INSERT INTO posts (title, slug, content, status, user_id)
    SELECT 'First Post',  'first-post',  'Hello from Alice!',   'published', id FROM users WHERE email = 'alice@example.com'
  UNION ALL
    SELECT 'Second Post', 'second-post', 'Another from Alice.', 'draft',     id FROM users WHERE email = 'alice@example.com'
  UNION ALL
    SELECT 'Bobs Post',   'bobs-post',   'Hello from Bob!',     'published', id FROM users WHERE email = 'bob@example.com';
"""

console.log 'Setup: tables created + 5 users + 3 posts seeded\n'

# ==============================================================================
# Model Definition — one construct does everything
# ==============================================================================

User = schema.model 'User',
  greet: -> "Hello, #{@name}!"
  displayRole: -> @role.charAt(0).toUpperCase() + @role.slice(1)
  computed:
    identifier: -> "#{@name} <#{@email}>"
    isAdmin:    -> @role is 'admin'

Post = schema.model 'Post',
  computed:
    summary: -> "#{@title} (#{@status})"

# ==============================================================================
# Query Examples
# ==============================================================================

console.log '── Find first user ─────────────────────────────────────────'
user = User.first!()
console.log user?.toJSON()
console.log "Greeting: #{user?.greet()}"

console.log '\n── Find by email ───────────────────────────────────────────'
user = User.where!(email: 'bob@example.com').first!()
console.log user?.toJSON()

console.log '\n── Computed properties ─────────────────────────────────────'
user = User.where!(name: 'Alice').first!()
console.log "identifier: #{user?.identifier}"
console.log "isAdmin:    #{user?.isAdmin}"

console.log '\n── All users ───────────────────────────────────────────────'
users = User.all!()
for u in users
  console.log "  #{u.identifier} — role=#{u.displayRole()} admin=#{u.isAdmin}"

console.log '\n── Where (object style) ────────────────────────────────────'
users = User.where!(role: 'editor').all!()
console.log users.map (u) -> u.toJSON()

console.log '\n── Where (SQL style) ───────────────────────────────────────'
users = User.where!('active = ?', true).all!()
console.log "Active users:", users.map (u) -> u.identifier

console.log '\n── Chainable query ─────────────────────────────────────────'
users = User.where!('active = ?', true).orderBy!('name').limit!(3).all!()
console.log "First 3 active:", users.map (u) -> u.name

console.log '\n── Count ───────────────────────────────────────────────────'
console.log "Total users: #{User.count!()}"

console.log '\n── Instance method ─────────────────────────────────────────'
user = User.first!()
console.log "Role: #{user.displayRole()}"

console.log '\n── Property mutation + dirty tracking ──────────────────────'
user = User.where!(name: 'Alice').first!()
console.log "Before: #{user.name}, dirty=#{user.$dirty}"
user.name = "Alice Updated"
console.log "After:  #{user.name}, dirty=#{user.$dirty}, changed=#{user.$changed}"

console.log '\n── Relation loading: user.posts() ──────────────────────────'
alice = User.where!(name: 'Alice').first!()
posts = alice.posts!()
console.log "Alice has #{posts.length} posts:"
for p in posts
  console.log "  - #{p.summary}"

console.log '\n── Relation loading: post.user() ───────────────────────────'
post = Post.where!(slug: 'bobs-post').first!()
author = post.user!()
console.log "#{post.title} was written by #{author.name}"

console.log '\n── Eager loading: include ──────────────────────────────────'
# 2 queries instead of N+1 — all posts pre-loaded
usersWithPosts = User.include!('posts').where!(active: true).all!()
for u in usersWithPosts
  posts = u.posts!()  # no query — returns pre-loaded data
  console.log "  #{u.name}: #{posts.length} posts"

console.log '\n── Soft delete ─────────────────────────────────────────────'
allPosts = Post.all!()
console.log "Total posts: #{allPosts.length}"

# Soft-delete Bob's post (sets deleted_at, doesn't actually DELETE)
bobs = Post.where!(slug: 'bobs-post').first!()
bobs.softDelete!()
console.log "Soft-deleted: #{bobs.title}"

# Default queries now exclude it
remaining = Post.all!()
console.log "Visible posts: #{remaining.length}"

# withDeleted() includes soft-deleted records
everything = Post.withDeleted!().all!()
console.log "Including deleted: #{everything.length}"

# Restore it
bobs.restore!()
restored = Post.all!()
console.log "After restore: #{restored.length}"

console.log '\n── Factory: auto-generated data ────────────────────────────'
fakeUser = User.factory!(0)
console.log "Built (not saved):", fakeUser.toJSON()

console.log '\n── Factory: batch create ───────────────────────────────────'
editors = User.factory!(3, role: 'editor')
console.log "Created #{editors.length} editors:"
for e in editors
  console.log "  - #{e.name} <#{e.email}> role=#{e.role}"

console.log '\n── Factory: total after batch ──────────────────────────────'
console.log "Total users now: #{User.count!()}"

console.log '\n── Validation ──────────────────────────────────────────────'
badUser = User.build email: 'not-valid'
errors = badUser.$validate()
console.log "Validation errors:", errors

console.log '\n── Done! ───────────────────────────────────────────────────'
