# Test: Implicit Commas Before Arrow Functions
# Tests automatic comma insertion before -> and => in function calls
# Allows: get '/users' -> ... instead of: get '/users', -> ...

# ============================================================================
# STRING -> (route handlers, event handlers)
# ============================================================================

# Basic string to arrow (thin)
code "string arrow thin", "get '/users' -> 1", "get('/users', function() {\n  return 1;\n});"
code "string arrow thin block", "get '/users' ->\n  1", "get('/users', function() {\n  return 1;\n});"

# Basic string to arrow (fat)
code "string fat arrow", "get '/users' => 1", "get('/users', () => 1);"
code "string fat arrow block", "get '/users' =>\n  1", "get('/users', () => 1);"

# Multiple route handlers
code "multiple routes", "get '/a' -> 1\nget '/b' -> 2", "get('/a', function() {\n  return 1;\n});\n\nget('/b', function() {\n  return 2;\n});"

# Nested/chained calls
code "chained call string arrow", "app.get '/users' -> 1", "app.get('/users', function() {\n  return 1;\n});"

# With explicit comma still works
code "explicit comma still works", "get '/users', -> 1", "get('/users', function() {\n  return 1;\n});"

# Runtime tests for string arrows
test "string arrow runtime", "handler = (path, fn) -> fn()\nhandler '/test' -> 42", 42
test "string fat arrow runtime", "handler = (path, fn) -> fn()\nhandler '/test' => 42", 42

# ============================================================================
# REGEX -> (pattern matching routes)
# ============================================================================

# Basic regex to arrow
code "regex arrow thin", "get /^\\/api/ -> 1", "get(/^\\/api/, function() {\n  return 1;\n});"
code "regex fat arrow", "get /^\\/api/ => 1", "get(/^\\/api/, () => 1);"

# Complex regex patterns
code "regex complex", "match /^user-(\\d+)$/ -> 1", "match(/^user-(\\d+)$/, function() {\n  return 1;\n});"

# Runtime tests for regex arrows
test "regex arrow runtime", "handler = (pattern, fn) -> fn()\nhandler /test/ -> 42", 42
test "regex fat arrow runtime", "handler = (pattern, fn) -> fn()\nhandler /test/ => 42", 42

# ============================================================================
# NUMBER -> (status codes, priorities, indexes)
# ============================================================================

# Basic number to arrow
code "number arrow thin", "handle 404 -> 1", "handle(404, function() {\n  return 1;\n});"
code "number fat arrow", "handle 404 => 1", "handle(404, () => 1);"

# Multiple number handlers
code "multiple number handlers", "handle 404 -> 1\nhandle 500 -> 2", "handle(404, function() {\n  return 1;\n});\n\nhandle(500, function() {\n  return 2;\n});"

# Runtime tests for number arrows
test "number arrow runtime", "handler = (code, fn) -> fn()\nhandler 404 -> 'not found'", "not found"
test "number fat arrow runtime", "handler = (code, fn) -> fn()\nhandler 500 => 'error'", "error"

# ============================================================================
# Mixed scenarios
# ============================================================================

# Object return
code "arrow with object", "get '/config' -> { port: 3000 }", "get('/config', function() {\n  return {port: 3000};\n});"

# Expression body with explicit param
test "arrow expression body", "run = (name, fn) -> fn(10)\nrun 'double', (x) -> x * 2", 20

# Multiple arguments before arrow still need comma
code "multi arg needs comma", "get '/users', opts, -> 1", "get('/users', opts, function() {\n  return 1;\n});"

# ============================================================================
# BOOL -> (conditional handlers)
# ============================================================================

code "bool true arrow", "check true -> 1", "check(true, function() {\n  return 1;\n});"
code "bool false arrow", "check false -> 0", "check(false, function() {\n  return 0;\n});"
test "bool arrow runtime", "handler = (flag, fn) -> fn()\nhandler true -> 'yes'", "yes"

# ============================================================================
# NULL / UNDEFINED -> (default handlers)
# ============================================================================

code "null arrow", "handle null -> 'default'", "handle(null, function() {\n  return 'default';\n});"
code "undefined arrow", "handle undefined -> 'missing'", "handle(undefined, function() {\n  return 'missing';\n});"
test "null arrow runtime", "handler = (val, fn) -> fn()\nhandler null -> 'null!'", "null!"
test "undefined arrow runtime", "handler = (val, fn) -> fn()\nhandler undefined -> 'undef!'", "undef!"

# ============================================================================
# INFINITY / NAN -> (edge case handlers)
# ============================================================================

code "infinity arrow", "handle Infinity -> 'overflow'", "handle(Infinity, function() {\n  return 'overflow';\n});"
code "nan arrow", "handle NaN -> 'invalid'", "handle(NaN, function() {\n  return 'invalid';\n});"
test "infinity arrow runtime", "handler = (val, fn) -> fn()\nhandler Infinity -> 'inf!'", "inf!"

# ============================================================================
# Arrays -> (pattern matching)
# ============================================================================

code "array arrow", "match [1, 2, 3] -> 'found'", "match([1, 2, 3], function() {\n  return 'found';\n});"
code "empty array arrow", "match [] -> 'empty'", "match([], function() {\n  return 'empty';\n});"
test "array arrow runtime", "handler = (arr, fn) -> fn()\nhandler [1, 2] -> 'got array'", "got array"

# ============================================================================
# Objects -> (shape matching)
# ============================================================================

code "object arrow", "match {x: 1} -> 'found'", "match({x: 1}, function() {\n  return 'found';\n});"
code "empty object arrow", "match {} -> 'empty'", "match({}, function() {\n  return 'empty';\n});"
test "object arrow runtime", "handler = (obj, fn) -> fn()\nhandler {a: 1} -> 'got object'", "got object"

# ============================================================================
# NO comma insertion (these are function params, not call args)
# ============================================================================

# IDENTIFIER before arrow - note: x -> gets parsed as x( -> ), not as (x) ->
# Single param needs parens: (x) -> or use fat arrow for implicit param
test "identifier param works", "[1,2,3].map (x) -> x * 2", [2, 4, 6]

# Parenthesized params stay as params
code "parens are params", "map (x) -> x * 2", "map(function(x) {\n  return (x * 2);\n});"
code "multi params", "reduce (a, b) -> a + b", "reduce(function(a, b) {\n  return (a + b);\n});"

# Combined: string arg + param function
test "string then param fn", "run = (path, fn) -> fn(5)\nrun '/api', (x) -> x * 2", 10
