# Test: Rip Types
# Tests the optional type system — type annotations, type aliases,
# structural types, interfaces, enums, generics, and .d.ts emission.
#
# Type annotations are erased from .js output. The `types: true` option
# enables .d.ts emission via emitTypes().

# ==============================================================================
# Type Annotations on Variables — Erased from JS
# ==============================================================================

code "typed variable", "count:: number = 0", "let count;\ncount = 0"
code "typed string variable", 'name:: string = "Rip"', 'let name;\nname = "Rip"'
code "typed array variable", "ids:: number[] = []", "let ids;\nids = []"
code "typed generic variable", "items:: Map<string, number> = x", "let items;\nitems = x"

# ==============================================================================
# Type Annotations on Constants — Erased from JS
# ==============================================================================

code "typed constant", "MAX:: number =! 100", "const MAX = 100"
code "typed string constant", 'URL:: string =! "https://example.com"', 'const URL = "https://example.com"'

# ==============================================================================
# Type Annotations on Functions — Erased from JS
# ==============================================================================

code "typed function params", '''
  def add(a:: number, b:: number)
    a + b
  ''', '''
  function add(a, b) {
    return (a + b);
  }
  '''

code "typed function return", '''
  def greet(name:: string):: string
    "Hello, #{name}!"
  ''', '''
  function greet(name) {
    return `Hello, ${name}!`;
  }
  '''

code "parameterless typed function", '''
  def answer():: number
    42
  ''', '''
  function answer() {
    return 42;
  }
  '''

code "typed function three params", '''
  def clamp(val:: number, min:: number, max:: number):: number
    Math.max(min, Math.min(max, val))
  ''', '''
  function clamp(val, min, max) {
    return Math.max(min, Math.min(max, val));
  }
  '''

# ==============================================================================
# Type-Only Declarations — Erased from JS
# ==============================================================================

# Simple aliases
code "type alias erased", "ID ::= number", ""
code "union type alias erased", 'UserID ::= number | string', ""

# Structural types
code "structural type erased", '''
  User ::= type
    id: number
    name: string
  ''', ""

code "structural type optional prop erased", '''
  Config ::= type
    host: string
    port: number
    ssl?: boolean
  ''', ""

# Block unions
code "block union erased", '''
  Status ::=
    | "pending"
    | "active"
    | "done"
  ''', ""

# Interfaces
code "interface erased", '''
  interface Animal
    name: string
    age: number
  ''', ""

code "interface extends erased", '''
  interface Dog extends Animal
    breed: string
  ''', ""

# Multiple type declarations in sequence
code "multiple types erased", '''
  ID ::= number
  Name ::= string
  Status ::= "active" | "inactive"
  ''', ""

# Multiple interfaces in sequence
code "multiple interfaces erased", '''
  interface Readable
    read: () => string
  interface Writable
    write: (data:: string) => boolean
  ''', ""

# ==============================================================================
# Enums — Runtime JS Output
# ==============================================================================

test "enum creates object", '''
  enum Color
    red = 0
    green = 1
    blue = 2
  Color.red
  ''', 0

test "enum reverse mapping", '''
  enum Color
    red = 0
    green = 1
    blue = 2
  Color[1]
  ''', "green"

test "enum with large values", '''
  enum HttpCode
    ok = 200
    created = 201
    notFound = 404
    serverError = 500
  HttpCode.ok + HttpCode.notFound
  ''', 604

test "enum member access", '''
  enum Dir
    up = 0
    down = 1
    left = 2
    right = 3
  [Dir.up, Dir.down, Dir.left, Dir.right]
  ''', [0, 1, 2, 3]

test "enum reverse all", '''
  enum Size
    sm = 1
    md = 2
    lg = 3
  [Size[1], Size[2], Size[3]]
  ''', ["sm", "md", "lg"]

# ==============================================================================
# Runtime Behavior — Types Don't Affect Execution
# ==============================================================================

test "typed variable runtime", "count:: number = 42; count", 42
test "typed constant runtime", 'msg:: string =! "hello"; msg', "hello"
test "typed boolean runtime", "flag:: boolean = true; flag", true
test "typed null runtime", "val:: string = null; val", null

test "typed function runtime", '''
  def double(x:: number):: number
    x * 2
  double(21)
  ''', 42

test "typed params runtime", '''
  def add(a:: number, b:: number):: number
    a + b
  add(3, 4)
  ''', 7

test "typed function multiple calls", '''
  def square(n:: number):: number
    n * n
  square(3) + square(4)
  ''', 25

test "typed function with string return", '''
  def shout(msg:: string):: string
    msg.toUpperCase()
  shout("hello")
  ''', "HELLO"

test "typed function with array return", '''
  def wrap(x:: number):: number[]
    [x]
  wrap(42)
  ''', [42]

test "typed parameterless runtime", '''
  def pi():: number
    3.14159
  pi()
  ''', 3.14159

# ==============================================================================
# Mixed: Types + Code Coexisting
# ==============================================================================

test "type alias with code", '''
  ID ::= number
  x = 42
  x
  ''', 42

test "interface with code", '''
  interface Config
    host: string
    port: number
  x = 99
  x
  ''', 99

test "enum with other code", '''
  enum Dir
    up = 0
    down = 1
  x = Dir.up
  x
  ''', 0

test "multiple types then code", '''
  ID ::= number
  Name ::= string
  interface User
    id: number
    name: string
  x = "works"
  x
  ''', "works"

test "type alias between functions", '''
  def first():: number
    1
  ID ::= number
  def second():: number
    2
  first() + second()
  ''', 3

test "interface then enum then code", '''
  interface Shape
    area: number
  enum Color
    red = 0
    blue = 1
  result = Color.red
  result
  ''', 0

test "enum used in computation", '''
  enum Op
    add = 1
    sub = 2
    mul = 3
  def apply(op:: number, a:: number, b:: number):: number
    if op is Op.add
      a + b
    else if op is Op.mul
      a * b
    else
      a - b
  apply(Op.add, 10, 20)
  ''', 30

# ==============================================================================
# Complex Type Annotations
# ==============================================================================

# Generic types survive in annotations without affecting JS
code "nested generic annotation", "cache:: Map<string, Set<number>> = x", "let cache;\ncache = x"

# Multiple typed variables in sequence
test "multiple typed variables", '''
  a:: number = 10
  b:: number = 20
  c:: number = 30
  a + b + c
  ''', 60

# Typed variables used together
test "typed variables in expression", '''
  width:: number = 5
  height:: number = 10
  width * height
  ''', 50

# Typed constant used in function
test "typed constant in function", '''
  PI:: number =! 3.14159
  def circleArea(r:: number):: number
    PI * r * r
  circleArea(1)
  ''', 3.14159

# ==============================================================================
# Generic Functions — Types Erased from JS
# ==============================================================================

test "generic function runtime", '''
  def identity<T>(value:: T):: T
    value
  identity(42)
  ''', 42

test "generic function with string", '''
  def identity<T>(value:: T):: T
    value
  identity("hello")
  ''', "hello"

test "generic function with array", '''
  def first<T>(items:: T[]):: T
    items[0]
  first([10, 20, 30])
  ''', 10

# ==============================================================================
# Structural Types with Optional Properties
# ==============================================================================

code "optional property erased", '''
  Config ::= type
    host: string
    port: number
    ssl?: boolean
    timeout?: number
  ''', ""

# ==============================================================================
# Block Unions — Various Forms
# ==============================================================================

code "block union three members", '''
  Light ::=
    | "red"
    | "yellow"
    | "green"
  ''', ""

code "block union many members", '''
  HttpMethod ::=
    | "GET"
    | "POST"
    | "PUT"
    | "PATCH"
    | "DELETE"
  ''', ""

# ==============================================================================
# Edge Cases
# ==============================================================================

# Type annotation with no assignment (in a function body)
test "typed param used in expression", '''
  def negate(x:: number):: number
    -x
  negate(5)
  ''', -5

# Enum with single member
test "enum single member", '''
  enum Single
    only = 1
  Single.only
  ''', 1

# Type alias then immediate use
test "type alias immediate code", '''
  ID ::= number
  id = 123
  id
  ''', 123

# Sequential enums
test "multiple enums", '''
  enum A
    x = 1
  enum B
    y = 2
  A.x + B.y
  ''', 3

# Typed function calling another typed function
test "typed functions calling each other", '''
  def double(n:: number):: number
    n * 2
  def quadruple(n:: number):: number
    double(double(n))
  quadruple(5)
  ''', 20

# Function with many typed params
test "function many typed params", '''
  def sum5(a:: number, b:: number, c:: number, d:: number, e:: number):: number
    a + b + c + d + e
  sum5(1, 2, 3, 4, 5)
  ''', 15

# ==============================================================================
# .d.ts Emission Tests — verify type declarations are emitted correctly
# ==============================================================================

# Variables
type "typed variable dts", "count:: number = 0", "let count: number;"
type "typed constant dts", 'MAX:: number =! 100', "declare const MAX: number;"

# Reactive state
type "reactive state dts", "count:: number := 0", """
  interface Signal<T> { value: T; read(): T; lock(): Signal<T>; free(): Signal<T>; kill(): T; }

  declare const count: Signal<number>;
  """

# Computed
type "computed dts", """
  count:: number := 0
  doubled:: number ~= count * 2
  """, """
  interface Signal<T> { value: T; read(): T; lock(): Signal<T>; free(): Signal<T>; kill(): T; }
  interface Computed<T> { readonly value: T; read(): T; lock(): Computed<T>; free(): Computed<T>; kill(): T; }

  declare const count: Signal<number>;
  declare const doubled: Computed<number>;
  """

# Effect
type "effect dts", "logger:: Function ~> console.log 42", "declare const logger: () => void;"

# Functions
type "typed function dts", '''
  def greet(name:: string):: string
    "Hello, #{name}!"
  ''', 'declare function greet(name: string): string;'

# Generics
type "generic function dts", '''
  def add<T>(a:: T, b:: T):: T
    a + b
  ''', 'declare function add<T>(a: T, b: T): T;'

# Generic constraints
type "generic constraint dts", '''
  def identity<T extends object>(v:: T):: T
    v
  ''', 'declare function identity<T extends object>(v: T): T;'

# Type alias
type "type alias dts", """
  User ::= type
    id: number
    name: string
    email?: string
  """, """
  type User = {
    id: number;
    name: string;
    email?: string;
  };
  """

# Interface
type "interface dts", """
  interface Readable
    read: => string
  """, """
  interface Readable {
    read: () => string;
  }
  """

# Enum
type "enum dts", """
  enum Direction
    North
    South
  """, """
  enum Direction {
    North,
    South
  }
  """

# Export reactive
type "export reactive dts", "export count:: number := 0", """
  interface Signal<T> { value: T; read(): T; lock(): Signal<T>; free(): Signal<T>; kill(): T; }

  export const count: Signal<number>;
  """

# Arrow function
type "arrow function dts", 'greet = (name:: string) -> "Hello"', "declare function greet(name: string);"

# Class with methods
type "class with methods dts", """
  class UserService
    url:: string = ""
    constructor: (@url:: string) ->
    fetch: (id:: number) ->
      console.log id
  """, """
  declare class UserService {
    url: string;
    constructor(url: string);
    fetch(id: number);
  }
  """

type "interface with :: annotations", """
  interface User
    id:: number
    name:: string
    email:: string
    isAdmin?:: boolean
  """, """
  interface User {
    id: number;
    name: string;
    email: string;
    isAdmin?: boolean;
  }
  """

type "export interface with :: annotations", """
  export interface Config
    host:: string
    port:: number
  """, """
  export interface Config {
    host: string;
    port: number;
  }
  """
