# Test: Conditionals (2 node types)
# Tests "if" and "unless" node types

# ============================================================================
# If Statements: "if"
# ============================================================================

# Basic if
test "if true", "if true\n  42", 42
test "if false", "if false\n  42\nelse\n  10", 10

# If with else
test "if else true branch", "x = if true then 'yes' else 'no'\nx", "yes"
test "if else false branch", "x = if false then 'yes' else 'no'\nx", "no"

# If as expression
test "if expression", "x = if 5 > 3 then 'greater' else 'less'\nx", "greater"

# Nested if
test "nested if", "x = if true\n  if true\n    42\n  else\n    10\nx", 42

# If with multiple conditions
test "if else if", "x = 2\ny = if x == 1\n  'one'\nelse if x == 2\n  'two'\nelse\n  'other'\ny", "two"

# Postfix if
test "postfix if true", "x = 42 if true\nx", 42
test "postfix if false", "x = 42 if false\nx", undefined

# If in function
test "if in function", "fn = (x) ->\n  if x > 0\n    'positive'\n  else\n    'negative'\nfn(5)", "positive"

# Code generation
code "simple if", "if cond then a else b", "if (cond) { a; } else { b; }"

# ============================================================================
# Unless Statements: "unless"
# ============================================================================

# Basic unless
test "unless false", "unless false\n  42", 42
test "unless true", "unless true\n  42\nelse\n  10", 10

# Unless as expression
test "unless expression", "x = unless false then 'yes' else 'no'\nx", "yes"

# Postfix unless
test "postfix unless false", "x = 42 unless false\nx", 42
test "postfix unless true", "x = 42 unless true\nx", undefined

# Unless vs if not
test "unless vs if not", "a = unless true then 1 else 2; b = if !true then 1 else 2; a == b", true

# Code generation
code "unless", "unless cond then a", "if (!cond) { a; }"

# ============================================================================
# Ternary Operator: "?:"
# ============================================================================

# Basic ternary
test "ternary true", "true ? 'yes' : 'no'", "yes"
test "ternary false", "false ? 'yes' : 'no'", "no"

# Ternary with expressions
test "ternary with comparison", "5 > 3 ? 'greater' : 'less'", "greater"
test "ternary with operations", "10 > 5 ? 100 + 1 : 200 + 1", 101

# Nested ternary
test "nested ternary", "x = 2\nx == 1 ? 'one' : x == 2 ? 'two' : 'other'", "two"

# Ternary as expression
test "ternary in assignment", "x = true ? 42 : 10\nx", 42
test "ternary in function", "fn = (cond) -> cond ? 'yes' : 'no'\nfn(true)", "yes"

# Code generation
code "simple ternary", "true ? 1 : 2", "(true ? 1 : 2)"
code "nested ternary", "true ? 1 : false ? 2 : 3", "(true ? 1 : (false ? 2 : 3))"

# ============================================================================
# Switch Statements: "switch"
# ============================================================================

# Basic switch with value
test "switch with value", "x = 2; result = switch x\n  when 1 then 'one'\n  when 2 then 'two'\n  else 'other'\nresult", "two"

# Switch with multiple cases
test "switch multiple when", "x = 3; result = switch x\n  when 1, 2 then 'low'\n  when 3, 4 then 'mid'\n  else 'high'\nresult", "mid"

# Switch with default
test "switch default", "x = 10; result = switch x\n  when 1 then 'one'\n  when 2 then 'two'\n  else 'other'\nresult", "other"

# Switch without discriminant (condition-based)
test "switch no discriminant", "x = 15; result = switch\n  when x < 10 then 'low'\n  when x < 20 then 'mid'\n  else 'high'\nresult", "mid"

# Switch with blocks
test "switch with block", "x = 2; result = switch x\n  when 1\n    'one'\n  when 2\n    'two'\n  else\n    'other'\nresult", "two"

# Switch without discriminant in statement context (loop)
test "switch in loop for side effects", '''
  count = 0
  for x in [1, 2, 3]
    switch
      when x == 1
        count += 1
      when x == 2
        count += 10
      when x == 3
        count += 100
  count
''', 111

# Code generation
code "switch", "switch x\n  when 1 then 'one'\n  else 'other'", "switch (x) {\n  case 1:\n    'one';\n    break;\n  default:\n    'other';\n    break;\n}"

# ============================================================================
# Statement Blocks: "block"
# ============================================================================

# Block in function
test "block in function", "fn = ->\n  x = 5\n  y = 10\n  x + y\nfn()", 15

# Block in if statement
test "block in if", "x = if true\n  a = 5\n  b = 10\n  a + b\nx", 15

# Block with multiple statements
test "multiple statements", "fn = ->\n  a = 1\n  b = 2\n  c = 3\n  a + b + c\nfn()", 6

# Empty block (edge case)
test "empty block", "fn = ->\nfn()", undefined

# Nested blocks
test "nested blocks", "fn = ->\n  if true\n    x = 5\n    y = 10\n    x + y\nfn()", 15

# ============================================================================
# Do IIFE: "do-iife"
# ============================================================================

# Basic do expression
test "do expression", "x = do -> 42\nx", 42

# Do with multiple statements
test "do block", "x = do ->\n  a = 5\n  b = 10\n  a + b\nx", 15

# Do with parameters
test "do with params", "counter = do (count = 0) -> -> count++\n[counter(), counter(), counter()]", [0, 1, 2]

# Async do
test "async do", "x = do -> await Promise.resolve(42)\nx", 42

# Code generation
code "do expression", "do -> 42", "(function() { return 42; })()"
code "do block", "do ->\n  x = 5\n  x * 2", "(function() {\n  let x;\n  x = 5;\n  return (x * 2);\n})();"

# ============================================================================
# Control flow short-circuits: or return / or throw / and return / and throw
# ============================================================================

# or return - returns when expression is falsy
test "or return with assignment falsy", """
  fn = ->
    sql = null or return 'empty'
    'got: ' + sql
  fn()
""", "empty"

test "or return with assignment truthy", """
  fn = ->
    sql = 'data' or return 'empty'
    'got: ' + sql
  fn()
""", "got: data"

# or throw - throws when expression is falsy
test "or throw with assignment falsy", """
  fn = ->
    try
      data = null or throw new Error 'No data'
      'got: ' + data
    catch e
      'caught: ' + e.message
  fn()
""", "caught: No data"

test "or throw with assignment truthy", """
  fn = ->
    try
      data = 'value' or throw new Error 'No data'
      'got: ' + data
    catch e
      'caught: ' + e.message
  fn()
""", "got: value"

# and return - returns when expression is truthy
test "and return with assignment truthy", """
  fn = ->
    cached = 'cached!' and return 'cached!'
    'not cached'
  fn()
""", "cached!"

test "and return with assignment falsy", """
  fn = ->
    cached = null and return 'cached!'
    'not cached'
  fn()
""", "not cached"

# and throw - throws when expression is truthy
test "and throw with assignment truthy", """
  fn = ->
    try
      error = 'validation failed' and throw new Error 'validation failed'
      'success'
    catch e
      'caught: ' + e.message
  fn()
""", "caught: validation failed"

test "and throw with assignment falsy", """
  fn = ->
    try
      error = null and throw new Error 'should not throw'
      'success'
    catch e
      'caught: ' + e.message
  fn()
""", "success"

# Standalone (no assignment)
test "standalone or return", """
  fn = (val) ->
    val or return 'fallback'
    'got: ' + val
  fn(null)
""", "fallback"

test "standalone and throw", """
  fn = (isError) ->
    try
      isError and throw new Error 'error!'
      'ok'
    catch e
      e.message
  fn(true)
""", "error!"

# Code generation tests
code "or return assignment generates if", """
  sql = read 'body' or return { error: 'Empty' }
""", """
let sql;

if (!(sql = read('body'))) return {error: 'Empty'};
"""

code "or throw assignment generates if", """
  data = fetchData() or throw new Error 'No data'
""", """
let data;

if (!(data = fetchData())) throw new Error('No data');
"""

code "and return assignment generates if", """
  cached = getCache() and return cached
""", """
let cached;

if ((cached = getCache())) return cached;
"""

code "and throw assignment generates if", """
  error = validate() and throw error
""", """
let error;

if ((error = validate())) throw error;
"""

code "standalone or return generates if", """
  checkAuth() or return { status: 401 }
""", """
if (!(checkAuth())) return {status: 401};
"""

code "standalone and throw generates if", """
  isError and throw new Error 'Failed'
""", """
if (isError) throw new Error('Failed');
"""

# ============================================================================
# Nullish coalescing control flow: ?? return / ?? throw
# Key difference: ?? only triggers on null/undefined, not other falsy values
# ============================================================================

# ?? return - returns only when expression is null/undefined
test "?? return with null", """
  fn = ->
    data = null ?? return 'was null'
    'got: ' + data
  fn()
""", "was null"

test "?? return with undefined", """
  fn = ->
    data = undefined ?? return 'was undefined'
    'got: ' + data
  fn()
""", "was undefined"

test "?? return with empty string (should NOT return)", """
  fn = ->
    data = '' ?? return 'was nullish'
    'got empty: ' + (data is '')
  fn()
""", "got empty: true"

test "?? return with zero (should NOT return)", """
  fn = ->
    data = 0 ?? return 'was nullish'
    'got zero: ' + data
  fn()
""", "got zero: 0"

test "?? return with false (should NOT return)", """
  fn = ->
    data = false ?? return 'was nullish'
    'got false: ' + data
  fn()
""", "got false: false"

test "?? return with truthy value", """
  fn = ->
    data = 'hello' ?? return 'was nullish'
    'got: ' + data
  fn()
""", "got: hello"

# ?? throw - throws only when expression is null/undefined
test "?? throw with null", """
  fn = ->
    try
      data = null ?? throw new Error 'was null'
      'got: ' + data
    catch e
      'caught: ' + e.message
  fn()
""", "caught: was null"

test "?? throw with undefined", """
  fn = ->
    try
      data = undefined ?? throw new Error 'was undefined'
      'got: ' + data
    catch e
      'caught: ' + e.message
  fn()
""", "caught: was undefined"

test "?? throw with empty string (should NOT throw)", """
  fn = ->
    try
      data = '' ?? throw new Error 'was nullish'
      'got empty: ' + (data is '')
    catch e
      'caught: ' + e.message
  fn()
""", "got empty: true"

test "?? throw with zero (should NOT throw)", """
  fn = ->
    try
      data = 0 ?? throw new Error 'was nullish'
      'got zero: ' + data
    catch e
      'caught: ' + e.message
  fn()
""", "got zero: 0"

# Standalone ?? return/throw
test "standalone ?? return with null", """
  fn = (val) ->
    val ?? return 'fallback'
    'got: ' + val
  fn(null)
""", "fallback"

test "standalone ?? return with empty string", """
  fn = (val) ->
    val ?? return 'fallback'
    'got empty: ' + (val is '')
  fn('')
""", "got empty: true"

test "standalone ?? throw with undefined", """
  fn = (val) ->
    try
      val ?? throw new Error 'was nullish'
      'got: ' + val
    catch e
      e.message
  fn(undefined)
""", "was nullish"

# Code generation tests for ?? variants
code "?? return assignment generates if with nullish check", """
  data = getValue() ?? return { error: 'No value' }
""", """
let data;

if ((data = getValue()) == null) return {error: 'No value'};
"""

code "?? throw assignment generates if with nullish check", """
  data = getValue() ?? throw new Error 'Missing'
""", """
let data;

if ((data = getValue()) == null) throw new Error('Missing');
"""

code "standalone ?? return generates if with nullish check", """
  checkValue() ?? return { status: 404 }
""", """
if ((checkValue()) == null) return {status: 404};
"""

code "standalone ?? throw generates if with nullish check", """
  getValue() ?? throw new Error 'Not found'
""", """
if ((getValue()) == null) throw new Error('Not found');
"""

# ============================================================================
# Switch with Explicit Returns
# ============================================================================

test 'switch case with explicit return', '''
  fn = (x) ->
    switch x
      when 'a'
        return "found a"
      when 'b'
        return "found b"
      else
        return "other"
  fn('b')
  ''', "found b"

test 'nested switch with explicit returns', '''
  outer = (x) ->
    switch x
      when 1
        switch x
          when 1
            return "one"
      else
        return "other"
  outer(1)
  ''', "one"

test 'switch with multi-statement block and return', '''
  fn = (x) ->
    y = 0
    z = 0
    switch x
      when 'a'
        y = 1
        z = 2
        return "result: #{y + z}"
  fn('a')
  ''', "result: 3"

code 'switch with explicit return', '''
  fn = (x) ->
    switch x
      when 'a'
        return "A"
  ''', '''
  let fn;
  fn = function(x) {
    switch (x) {
      case 'a':
        return "A";
    }
  };
'''

# ============================================================================
# Switch Case Labels
# ============================================================================

test 'switch with string cases', '''
  fn = (arg) ->
    switch arg
      when '-h', '--help'
        "help"
      when '-v'
        "version"
      else
        "unknown"
  fn('--help')
  ''', "help"

test 'switch with negative number case', '''
  fn = (x) ->
    switch x
      when -1
        "negative one"
      when 0
        "zero"
      else
        "other"
  fn(-1)
  ''', "negative one"

# ============================================================================
# Switch with Code After (Statement Context)
# ============================================================================

test 'switch assigns then uses result', '''
  fn = (mode) ->
    switch mode
      when 'a'
        result = 1
      when 'b'
        result = 2
      else
        result = 3
    result * 10
  [fn('a'), fn('b'), fn('c')]
  ''', [10, 20, 30]

test 'switch assigns in inner switch then uses result', '''
  fn = (action, mode) ->
    switch mode
      when 'sexp'
        switch action
          when 'string'
            result = 'str'
          when 'number'
            result = 'num'
          else
            result = 'other'
        result + '-processed'
      else
        'unknown'
  fn('string', 'sexp')
  ''', 'str-processed'

code 'switch statement with code after', '''
  fn = (x) ->
    switch x
      when 1
        result = 'one'
      when 2
        result = 'two'
      else
        result = 'other'
    return result
  ''', '''
  let fn;
  fn = function(x) {
    let result;
    switch (x) {
      case 1:
        result = 'one';
        break;
      case 2:
        result = 'two';
        break;
      default:
        result = 'other';
        break;
    }
    return result;
  };
'''

test "switch collects all variables from all cases", '''
  fn = (mode) ->
    switch mode
      when 1
        a = 10
        b = 20
        a + b
      when 2
        c = 30
        c * 2
      else
        d = 40
        d - 5
  [fn(1), fn(2), fn(3)]
  ''', [30, 60, 35]

# ============================================================================
# Postfix Unless/If
# ============================================================================

test 'return with postfix unless', '''
  fn = (x) ->
    return "yes" unless x
    "no"
  fn(false)
  ''', "yes"

test 'assignment with postfix unless', '''
  x = 5
  y = 10 unless x > 10
  y
  ''', 10

test 'expression with postfix unless', '''
  fn = (x) -> x * 2 unless x < 0
  fn(5)
  ''', 10

test "postfix unless with return - executes next statement", '''
  fn = (x) ->
    return "null" unless x?
    x * 2
  fn(5)
  ''', 10

test "postfix unless with return - returns early", '''
  fn = (x) ->
    return "null" unless x?
    x * 2
  fn(null)
  ''', "null"

test "postfix if with return", '''
  fn = (x) ->
    return "big" if x > 100
    x * 2
  fn(150)
  ''', "big"

test "postfix if with return - continues", '''
  fn = (x) ->
    return "big" if x > 100
    x * 2
  fn(50)
  ''', 100

test 'postfix unless on push no undefined', '''
  actions = []
  for item in [1, 2, 3, 4, 5]
    actions.push item unless item > 3
  actions
  ''', [1, 2, 3]

test 'postfix if on push', '''
  actions = []
  for item in [1, 2, 3, 4, 5]
    actions.push item if item > 3
  actions
  ''', [4, 5]

code 'postfix unless on call generates if statement', '''
  for item in arr
    actions.push item unless item > 3
  ''', '''
  for (const item of arr) {
    if (!(item > 3)) actions.push(item);
  }
'''

test 'postfix unless with binary op in argument', '''
  actions = []
  for item in [1, 2, 3]
    actions.push "item:" + item unless item > 2
  actions
  ''', ["item:1", "item:2"]

code 'return with postfix unless', '''
  fn = -> return 5 unless x
  ''', '''
  let fn;
  fn = function() {
    if (!x) return 5;
  };
'''

test 'conditional assignment with typeof check', '''
  lookup = (x) ->
    result = null
    if typeof x isnt "number"
      result = x or "not-found"
    result
  [lookup(42), lookup("hello"), lookup(null)]
  ''', [null, "hello", "not-found"]

# ============================================================================
# If/Else Unreachable Code
# ============================================================================

test 'if else with returns', '''
  fn = (x) ->
    if x then return "yes" else return "no"
  fn(true)
  ''', "yes"

test 'unless else with returns', '''
  fn = (x) ->
    unless x then return "no" else return "yes"
  fn(true)
  ''', "yes"

# ============================================================================
# If/Else-If Chains
# ============================================================================

test "if-else-if chain 4 branches", '''
  fn = (x) ->
    if x is 1
      'one'
    else if x is 2
      'two'
    else if x is 3
      'three'
    else
      'other'
  [fn(1), fn(2), fn(3), fn(4)]
  ''', ['one', 'two', 'three', 'other']

test "if-else-if chain 5 branches", '''
  fn = (x) ->
    if x is 1 then 'one'
    else if x is 2 then 'two'
    else if x is 3 then 'three'
    else if x is 4 then 'four'
    else 'other'
  [fn(1), fn(2), fn(3), fn(4), fn(5)]
  ''', ['one', 'two', 'three', 'four', 'other']

test "nested if-else-if in value context", '''
  x = 7
  result = if x > 10
    'big'
  else if x > 5
    'medium'
  else if x > 0
    'small'
  else
    'zero or negative'
  result
  ''', 'medium'

test "multi-branch if-else-if returns correct value", '''
  fn = (x) ->
    if typeof x is 'number'
      "number"
    else if typeof x is 'string'
      "string"
    else if typeof x is 'boolean'
      "boolean"
    else if Array.isArray(x)
      "array"
    else
      "other"
  [fn(42), fn("hi"), fn(true), fn([1]), fn(null)]
  ''', ["number", "string", "boolean", "array", "other"]

code "if-else-if generates proper chain", '''
  x = if a then 1 else if b then 2 else if c then 3 else 4
  ''', '''
  let x;
  x = a ? 1 : (b ? 2 : (c ? 3 : 4));
'''

# ============================================================================
# If/Else as Last Statement (IIFE avoidance)
# ============================================================================

test 'if/else as last statement no IIFE needed', '''
  fn = (handle) ->
    if Array.isArray handle
      symbols = handle[0]
      action = handle[1]
      [symbols, action]
    else
      symbols = handle.split(' ')
      [symbols, null]
  result = fn(['a', 'b'])
  result
  ''', ['a', 'b']

test 'if/else multi-statement returns correctly', '''
  fn = (x) ->
    if x > 0
      a = x * 2
      b = a + 10
      [a, b]
    else
      c = x * -1
      [c, 0]
  fn(5)
  ''', [10, 20]

code 'if/else last statement uses early returns not IIFE', '''
  fn = (handle) ->
    if Array.isArray handle
      symbols = handle[0]
      action = handle[1]
      [symbols, action]
    else
      symbols = handle.split(' ')
      [symbols, null]
  ''', '''
  let fn;

  fn = function(handle) {
    let action, symbols;
    if (Array.isArray(handle)) {
      symbols = handle[0];
      action = handle[1];
      return [symbols, action];
    } else {
      symbols = handle.split(' ');
      return [symbols, null];
    }
};
'''

test 'if-else value context with statement after', '''
  fn = (cond) ->
    msg = if cond
      "yes"
    else
      "no"

    msg + "-processed"

  [fn(true), fn(false)]
  ''', ["yes-processed", "no-processed"]

test 'ternary with side effect after assignment', '''
  sideEffect = 0
  fn = (x) ->
    result = if x then "true" else "false"
    sideEffect = 1
    result
  [fn(true), sideEffect]
  ''', ["true", 1]

code 'if-else in value context uses ternary not IIFE for simple branches', '''
  x = if cond then "yes" else "no"
  ''', '''
  let x;
  x = cond ? "yes" : "no";
'''

# ============================================================================
# Ternary Edge Cases
# ============================================================================

fail 'nested ternary in then branch', 'x = true ? (false ? "a" : "b") : "c"'

test 'nested ternary in else branch', '''
  x = 1
  y = 0
  z = 0
  result = x > 0 ? "x" : y > 0 ? "y" : z > 0 ? "z" : "none"
  result
  ''', "x"

test 'nested ternary with parens in else', '''
  x = 0
  y = 1
  result = x > 0 ? "x" : (y > 0 ? "y" : "none")
  result
  ''', "y"

test 'ternary in function', '''
  fn = (x) -> x > 0 ? "positive" : "negative"
  fn(5)
  ''', "positive"

test 'ternary with method call', '''
  x = "hello"
  result = x.length > 0 ? x.toUpperCase() : "empty"
  result
  ''', "HELLO"

code 'ternary with typeof and or - minimal parens', '''
  action = if typeof handle[1] is 'string' or handle.length is 3 then handle[1] else null
  ''', '''
  let action;
  action = ((typeof handle[1] === 'string') || (handle.length === 3)) ? handle[1] : null;
'''

test 'ternary with complex condition works', '''
  fn = (handle) ->
    action = if typeof handle[1] is 'string' or handle.length is 3 then handle[1] else null
    action
  fn([1, 'test', 3])
  ''', 'test'

# ============================================================================
# Postfix Conditional Variable Declarations
# ============================================================================

test "postfix if declares variable", '''
  fn = ->
    x = 5 if true
    y = 10 unless false
    x + y
  fn()
  ''', 15

test "timing-style conditional assignment", '''
  fn = (cond, val) ->
    result = val if cond
    result
  fn(true, 42)
  ''', 42

test "timing returns undefined when condition false", '''
  fn = (cond, val) ->
    result = val if cond
    result
  fn(false, 42)
  ''', undefined
