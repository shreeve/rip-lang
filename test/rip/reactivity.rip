# Test: Reactivity (4 node types)
# Tests the reactive operators: := (state), ~= (computed), ~> (effect),
# and =! (readonly). These compile to __state(), __computed(), __effect(),
# and const respectively.

# ============================================================================
# State (:=) — Code Generation
# ============================================================================

skip = { skipPreamble: true }

code "state creation", "count := 0", "const count = __state(0)", skip

code "state with string", 'name := "Rip"', 'const name = __state("Rip")', skip

code "state update", '''
  count := 0
  count += 1
  ''', '''
  const count = __state(0);
  count.value += 1
  ''', skip

code "state read", '''
  count := 0
  x = count
  ''', '''
  let x;

  const count = __state(0);
  x = count.value
  ''', skip

# ============================================================================
# Computed (~=) — Code Generation
# ============================================================================

code "computed creation", "doubled ~= count * 2", "const doubled = __computed(() => (count * 2))", skip

code "computed with expression", '''
  message ~= "Count is #{count}"
  ''', '''
  const message = __computed(() => `Count is ${count}`)
  ''', skip

# ============================================================================
# Effect (~>) — Code Generation
# ============================================================================

code "fire-and-forget effect", '''
  ~> console.log count
  ''', '''
  __effect(() => { console.log(count); })
  ''', skip

code "assigned effect", '''
  logger ~> console.log count
  ''', '''
  const logger = __effect(() => { console.log(count); })
  ''', skip

# ============================================================================
# Readonly (=!) — Code Generation
# ============================================================================

code "readonly constant", "MAX =! 100", "const MAX = 100"
code "readonly string", 'URL =! "https://example.com"', 'const URL = "https://example.com"'

# ============================================================================
# State (:=) — Runtime Behavior
# ============================================================================

test "state initial value", '''
  count := 0
  count + 0
  ''', 0

test "state update and read", '''
  count := 10
  count += 5
  count + 0
  ''', 15

test "state with string", '''
  name := "hello"
  name += " world"
  "" + name
  ''', "hello world"

test "state boolean coercion", '''
  flag := true
  flag is true
  ''', true

# ============================================================================
# Computed (~=) — Runtime Behavior
# ============================================================================

test "computed initial value", '''
  count := 5
  doubled ~= count * 2
  doubled + 0
  ''', 10

test "computed updates when state changes", '''
  count := 3
  doubled ~= count * 2
  count += 1
  doubled + 0
  ''', 8

test "computed with multiple dependencies", '''
  a := 2
  b := 3
  sum ~= a + b
  sum + 0
  ''', 5

test "computed chain", '''
  base := 10
  doubled ~= base * 2
  quadrupled ~= doubled * 2
  quadrupled + 0
  ''', 40

test "computed chain updates", '''
  base := 10
  doubled ~= base * 2
  quadrupled ~= doubled * 2
  base += 5
  quadrupled + 0
  ''', 60

# ============================================================================
# Readonly (=!) — Runtime Behavior
# ============================================================================

test "readonly value", "MAX =! 42; MAX", 42
test "readonly string", 'MSG =! "hi"; MSG', "hi"
test "readonly in expression", "PI =! 3; PI * 2", 6

# ============================================================================
# Mixed Reactive Patterns
# ============================================================================

test "state + computed together", '''
  width := 5
  height := 10
  area ~= width * height
  area + 0
  ''', 50

test "state + computed + update", '''
  price := 100
  tax ~= price * 0.1
  price += 50
  tax + 0
  ''', 15

test "multiple states", '''
  a := 1
  b := 2
  c := 3
  a + b + c + 0
  ''', 6

# ============================================================================
# Components with reactive state
# ============================================================================

test "component with state", '''
  A = component
    x := 5
  a = A.new()
  a.x.value
  ''', 5

test "component state mutation", '''
  A = component
    x := 10
  a = A.new()
  a.x.value = 20
  a.x.value
  ''', 20

test "component signal read", '''
  A = component
    x := 5
  a = A.new()
  a.x.read()
  ''', 5

# ============================================================================
# Effect Cleanup (~>) — Runtime Behavior
# ============================================================================

test "effect without cleanup still works", '''
  result := 0
  count := 1
  ~> result = count * 10
  count += 1
  result + 0
  ''', 20

test "effect cleanup runs before re-execution", '''
  log = []
  count := 0
  __effect ->
    v = count + 0
    log.push "run:#{v}"
    -> log.push "cleanup:#{v}"
  count += 1
  log.join ","
  ''', "run:0,cleanup:0,run:1"

test "effect cleanup on multiple re-runs", '''
  log = []
  count := 0
  __effect ->
    v = count + 0
    -> log.push "c:#{v}"
  count += 1
  count += 1
  log.join ","
  ''', "c:0,c:1"
