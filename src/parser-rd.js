// Predictive Recursive Descent Parser generated by Lunar

const ruleActions = (rule, vals, locs, shared) => {
    const $ = vals;
    const $0 = vals.length - 1;
    switch (rule) {
      case 1: return ["program"];
      case 2: return ["program", ...$[$0]];
      case 3: case 58: case 110: case 150: case 154: case 174: case 194: case 203: case 251: case 302: case 314: case 328: case 357: return [$[$0]];
      case 4: case 111: case 175: case 195: case 204: case 315: case 329: case 358: return [...$[$0-2], $[$0]];
      case 5: case 60: case 157: case 316: return $[$0-1];
      case 6: case 7: case 8: case 9: case 10: case 11: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 63: case 64: case 86: case 87: case 88: case 89: case 90: case 115: case 120: case 121: case 122: case 123: case 126: case 129: case 130: case 131: case 132: case 133: case 145: case 171: case 172: case 178: case 182: case 183: case 184: case 185: case 199: case 200: case 201: case 217: case 218: case 232: case 234: case 262: case 300: case 317: case 318: case 319: case 333: case 335: case 337: case 362: case 365: return $[$0];
      case 47: return "undefined";
      case 48: return "null";
      case 57: return ["str", ...$[$0-1]];
      case 59: case 151: case 155: case 252: return [...$[$0-1], $[$0]];
      case 61: case 193: case 197: case 331: case 360: return $[$0-2];
      case 62: return "";
      case 65: return ["regex", $[$0-1]];
      case 66: return ["regex-index", $[$0-2], $[$0]];
      case 67: return ["regex-index", $[$0], null];
      case 68: return ["=", $[$0-2], $[$0]];
      case 69: return ["=", $[$0-3], $[$0]];
      case 70: return ["=", $[$0-4], $[$0-1]];
      case 71: return ["state", $[$0-2], $[$0]];
      case 72: return ["state", $[$0-3], $[$0]];
      case 73: return ["state", $[$0-4], $[$0-1]];
      case 74: return ["computed", $[$0-2], $[$0]];
      case 75: return ["computed", $[$0-3], $[$0]];
      case 76: return ["computed", $[$0-4], $[$0-1]];
      case 77: return ["readonly", $[$0-2], $[$0]];
      case 78: return ["readonly", $[$0-3], $[$0]];
      case 79: return ["readonly", $[$0-4], $[$0-1]];
      case 80: return ["effect", $[$0-2], $[$0]];
      case 81: return ["effect", $[$0-3], $[$0]];
      case 82: return ["effect", $[$0-4], $[$0-1]];
      case 83: case 84: return ["effect", null, $[$0]];
      case 85: return ["effect", null, $[$0-1]];
      case 91: case 100: case 138: return [".", $[$0-2], $[$0]];
      case 92: case 101: case 139: return ["?.", $[$0-2], $[$0]];
      case 93: case 95: case 102: case 140: return ["[]", $[$0-3], $[$0-1]];
      case 94: case 96: case 103: case 141: return ["[]", $[$0-5], $[$0-2]];
      case 97: return [$[$0-1][0], $[$0-3], ...$[$0-1].slice(1)];
      case 98: return ["optindex", $[$0-4], $[$0-1]];
      case 99: return ["optindex", $[$0-6], $[$0-2]];
      case 104: return ["object-comprehension", $[$0-8], $[$0-6], [["for-of", $[$0-4], $[$0-2], false]], []];
      case 105: return ["object-comprehension", $[$0-10], $[$0-8], [["for-of", $[$0-6], $[$0-4], false]], [$[$0-2]]];
      case 106: return ["object-comprehension", $[$0-9], $[$0-7], [["for-of", $[$0-4], $[$0-2], true]], []];
      case 107: return ["object-comprehension", $[$0-11], $[$0-9], [["for-of", $[$0-6], $[$0-4], true]], [$[$0-2]]];
      case 108: return ["object", ...$[$0-2]];
      case 109: case 152: case 173: case 192: return [];
      case 112: case 176: case 196: case 330: case 359: return [...$[$0-3], $[$0]];
      case 113: case 177: case 198: case 332: case 361: return [...$[$0-5], ...$[$0-2]];
      case 114: return [$[$0], $[$0], null];
      case 116: return [$[$0-2], $[$0], ":"];
      case 117: return [$[$0-4], $[$0-1], ":"];
      case 118: return [$[$0-2], $[$0], "="];
      case 119: return [$[$0-4], $[$0-1], "="];
      case 124: return ["dynamicKey", $[$0-1]];
      case 125: return ["[]", "this", $[$0-1]];
      case 127: case 128: case 186: return ["...", $[$0]];
      case 134: case 190: return ["super", ...$[$0]];
      case 135: case 136: case 137: case 188: case 191: return [$[$0-1], ...$[$0]];
      case 142: return ["array"];
      case 143: return ["array", ...$[$0-1]];
      case 144: return ["array", ...$[$0-2], ...$[$0-1]];
      case 146: return [...$[$0-2], ...$[$0]];
      case 147: return [...$[$0-3], ...$[$0]];
      case 148: return [...$[$0-2], ...$[$0-1]];
      case 149: return [...$[$0-5], ...$[$0-4], ...$[$0-2], ...$[$0-1]];
      case 153: return [...$[$0]];
      case 156: return null;
      case 158: return "..";
      case 159: case 202: return "...";
      case 160: return [$[$0-2], $[$0-3], $[$0-1]];
      case 161: case 384: case 386: case 387: case 402: case 404: return [$[$0-1], $[$0-2], $[$0]];
      case 162: return [$[$0], $[$0-1], null];
      case 163: return [$[$0-1], null, $[$0]];
      case 164: return [$[$0], null, null];
      case 165: return ["def", $[$0-4], $[$0-2], $[$0]];
      case 166: return ["def", $[$0-1], [], $[$0]];
      case 167: case 169: return [$[$0-1], $[$0-3], $[$0]];
      case 168: case 170: return [$[$0-1], [], $[$0]];
      case 179: case 301: return ["default", $[$0-2], $[$0]];
      case 180: return ["rest", $[$0]];
      case 181: return ["expansion"];
      case 187: return ["tagged-template", $[$0-1], $[$0]];
      case 189: return ["optcall", $[$0-2], ...$[$0]];
      case 205: case 206: return "this";
      case 207: return [".", "this", $[$0]];
      case 208: return [".", "super", $[$0]];
      case 209: return ["[]", "super", $[$0-1]];
      case 210: return ["[]", "super", $[$0-2]];
      case 211: return [".", "new", $[$0]];
      case 212: return [".", "import", $[$0]];
      case 213: return ["block"];
      case 214: return ["block", ...$[$0-1]];
      case 215: return $[$0-1].length === 1 ? $[$0-1][0] : ["block", ...$[$0-1]];
      case 216: return $[$0-2].length === 1 ? $[$0-2][0] : ["block", ...$[$0-2]];
      case 219: return ["return", $[$0]];
      case 220: return ["return", $[$0-1]];
      case 221: return ["return"];
      case 222: return ["throw", $[$0]];
      case 223: return ["throw", $[$0-1]];
      case 224: return ["yield"];
      case 225: return ["yield", $[$0]];
      case 226: return ["yield", $[$0-1]];
      case 227: return ["yield-from", $[$0]];
      case 228: return ["if", $[$0-1], $[$0]];
      case 229: return $[$0-4].length === 3 ? ["if", $[$0-4][1], $[$0-4][2], ["if", $[$0-1], $[$0]]] : [...$[$0-4], ["if", $[$0-1], $[$0]]];
      case 230: return ["unless", $[$0-1], $[$0]];
      case 231: return ["if", ["!", $[$0-3]], $[$0-2], $[$0]];
      case 233: return $[$0-2].length === 3 ? ["if", $[$0-2][1], $[$0-2][2], $[$0]] : [...$[$0-2], $[$0]];
      case 235: case 236: return ["if", $[$0], [$[$0-2]]];
      case 237: return ["?:", $[$0-4], $[$0-6], $[$0-1]];
      case 238: case 239: return ["unless", $[$0], [$[$0-2]]];
      case 240: return ["try", $[$0]];
      case 241: return ["try", $[$0-1], $[$0]];
      case 242: return ["try", $[$0-2], $[$0]];
      case 243: return ["try", $[$0-3], $[$0-2], $[$0]];
      case 244: case 245: case 367: case 370: case 372: return [$[$0-1], $[$0]];
      case 246: return [null, $[$0]];
      case 247: return ["switch", $[$0-3], $[$0-1], null];
      case 248: return ["switch", $[$0-5], $[$0-3], $[$0-1]];
      case 249: return ["switch", null, $[$0-1], null];
      case 250: return ["switch", null, $[$0-3], $[$0-1]];
      case 253: return ["when", $[$0-1], $[$0]];
      case 254: return ["when", $[$0-2], $[$0-1]];
      case 255: return ["while", $[$0]];
      case 256: return ["while", $[$0-2], $[$0]];
      case 257: return ["until", $[$0]];
      case 258: return ["until", $[$0-2], $[$0]];
      case 259: return $[$0-1].length === 2 ? [$[$0-1][0], $[$0-1][1], $[$0]]   : [$[$0-1][0], $[$0-1][1], $[$0-1][2], $[$0]];
      case 260: case 261: return $[$0].length === 2 ? [$[$0][0], $[$0][1], [$[$0-1]]] : [$[$0][0], $[$0][1], $[$0][2], [$[$0-1]]];
      case 263: return ["loop", $[$0]];
      case 264: return ["loop", [$[$0]]];
      case 265: return ["loop-n", $[$0-1], $[$0]];
      case 266: return ["for-in"  , $[$0-3], $[$0-1], null, null, $[$0]];
      case 267: return ["for-in"  , $[$0-5], $[$0-3], null, $[$0-1], $[$0]];
      case 268: return ["for-in"  , $[$0-5], $[$0-3], $[$0-1], null, $[$0]];
      case 269: return ["for-in"  , $[$0-7], $[$0-5], $[$0-1], $[$0-3], $[$0]];
      case 270: return ["for-in"  , $[$0-7], $[$0-5], $[$0-3], $[$0-1], $[$0]];
      case 271: return ["for-of"  , $[$0-3], $[$0-1], false, null, $[$0]];
      case 272: return ["for-of"  , $[$0-5], $[$0-3], false, $[$0-1], $[$0]];
      case 273: return ["for-of"  , $[$0-3], $[$0-1], true, null, $[$0]];
      case 274: return ["for-of"  , $[$0-5], $[$0-3], true, $[$0-1], $[$0]];
      case 275: return ["for-as"  , $[$0-3], $[$0-1], false, null, $[$0]];
      case 276: return ["for-as"  , $[$0-5], $[$0-3], false, $[$0-1], $[$0]];
      case 277: case 279: return ["for-as"  , $[$0-3], $[$0-1], true, null, $[$0]];
      case 278: case 280: return ["for-as"  , $[$0-5], $[$0-3], true, $[$0-1], $[$0]];
      case 281: return ["for-in"  , [], $[$0-1], null, null, $[$0]];
      case 282: return ["for-in"  , [], $[$0-3], $[$0-1], null, $[$0]];
      case 283: return ["comprehension", $[$0-4], [["for-in"  , $[$0-2], $[$0], null]], []];
      case 284: return ["comprehension", $[$0-6], [["for-in"  , $[$0-4], $[$0-2], null]], [$[$0]]];
      case 285: return ["comprehension", $[$0-6], [["for-in"  , $[$0-4], $[$0-2], $[$0]]], []];
      case 286: return ["comprehension", $[$0-8], [["for-in"  , $[$0-6], $[$0-4], $[$0]]], [$[$0-2]]];
      case 287: return ["comprehension", $[$0-8], [["for-in"  , $[$0-6], $[$0-4], $[$0-2]]], [$[$0]]];
      case 288: return ["comprehension", $[$0-4], [["for-of"  , $[$0-2], $[$0], false]], []];
      case 289: return ["comprehension", $[$0-6], [["for-of"  , $[$0-4], $[$0-2], false]], [$[$0]]];
      case 290: return ["comprehension", $[$0-5], [["for-of"  , $[$0-2], $[$0], true]], []];
      case 291: return ["comprehension", $[$0-7], [["for-of"  , $[$0-4], $[$0-2], true]], [$[$0]]];
      case 292: return ["comprehension", $[$0-4], [["for-as"  , $[$0-2], $[$0], false, null]], []];
      case 293: return ["comprehension", $[$0-6], [["for-as"  , $[$0-4], $[$0-2], false, null]], [$[$0]]];
      case 294: return ["comprehension", $[$0-5], [["for-as"  , $[$0-2], $[$0], true, null]], []];
      case 295: return ["comprehension", $[$0-7], [["for-as"  , $[$0-4], $[$0-2], true, null]], [$[$0]]];
      case 296: return ["comprehension", $[$0-4], [["for-as"  , $[$0-2], $[$0], true, null]], []];
      case 297: return ["comprehension", $[$0-6], [["for-as"  , $[$0-4], $[$0-2], true, null]], [$[$0]]];
      case 298: return ["comprehension", $[$0-2], [["for-in", [], $[$0], null]], []];
      case 299: return ["comprehension", $[$0-4], [["for-in", [], $[$0-2], $[$0]]], []];
      case 303: case 334: case 336: case 363: case 364: case 366: return [$[$0-2], $[$0]];
      case 304: return ["class", null, null];
      case 305: return ["class", null, null, $[$0]];
      case 306: return ["class", null, $[$0]];
      case 307: return ["class", null, $[$0-1], $[$0]];
      case 308: return ["class", $[$0], null];
      case 309: return ["class", $[$0-1], null, $[$0]];
      case 310: return ["class", $[$0-2], $[$0]];
      case 311: return ["class", $[$0-3], $[$0-1], $[$0]];
      case 312: return ["enum", $[$0-1], $[$0]];
      case 313: return ["component", null, ["block", ...$[$0-1]]];
      case 320: return ["render", $[$0]];
      case 321: case 324: return ["import", "{}", $[$0]];
      case 322: case 323: return ["import", $[$0-2], $[$0]];
      case 325: return ["import", $[$0-4], $[$0]];
      case 326: return ["import", [$[$0-4], $[$0-2]], $[$0]];
      case 327: return ["import", [$[$0-7], $[$0-4]], $[$0]];
      case 338: return ["*", $[$0]];
      case 339: return ["export", "{}"];
      case 340: return ["export", $[$0-2]];
      case 341: case 342: case 343: case 344: case 348: case 349: case 350: case 351: return ["export", $[$0]];
      case 345: return ["export", ["=", $[$0-2], $[$0]]];
      case 346: return ["export", ["=", $[$0-3], $[$0]]];
      case 347: return ["export", ["=", $[$0-4], $[$0-1]]];
      case 352: return ["export-default", $[$0]];
      case 353: return ["export-default", $[$0-1]];
      case 354: return ["export-all", $[$0]];
      case 355: return ["export-from", "{}", $[$0]];
      case 356: return ["export-from", $[$0-4], $[$0]];
      case 368: case 369: case 371: case 407: return ["do-iife", $[$0]];
      case 373: return ["-", $[$0]];
      case 374: return ["+", $[$0]];
      case 375: return ["?", $[$0-1]];
      case 376: return ["await", $[$0]];
      case 377: return ["await", $[$0-1]];
      case 378: return ["--", $[$0], false];
      case 379: return ["++", $[$0], false];
      case 380: return ["--", $[$0-1], true];
      case 381: return ["++", $[$0-1], true];
      case 382: return ["+", $[$0-2], $[$0]];
      case 383: return ["-", $[$0-2], $[$0]];
      case 385: return ["**", $[$0-2], $[$0]];
      case 388: return ["&", $[$0-2], $[$0]];
      case 389: return ["^", $[$0-2], $[$0]];
      case 390: return ["|", $[$0-2], $[$0]];
      case 391: case 392: case 393: case 394: case 395: case 396: return ["control", $[$0-1], $[$0-2], $[$0]];
      case 397: return ["&&", $[$0-2], $[$0]];
      case 398: return ["||", $[$0-2], $[$0]];
      case 399: return ["??", $[$0-2], $[$0]];
      case 400: return ["!?", $[$0-2], $[$0]];
      case 401: return ["|>", $[$0-2], $[$0]];
      case 403: return ["?:", $[$0-4], $[$0-2], $[$0]];
      case 405: return [$[$0-3], $[$0-4], $[$0-1]];
      case 406: return [$[$0-2], $[$0-3], $[$0]];
    }
  };

let token, tokenText, tokenLoc, lexerAdapter;
const EOF = 1;

function advance() {
  token = lexerAdapter.lex() || EOF;
  tokenText = lexerAdapter.text;
  tokenLoc = lexerAdapter.loc || {};
  return tokenText;
}

function expect(tag) {
  if (token !== tag) {
    const got = token === EOF ? 'end of input' : ("'" + token + "'");
    const line = (tokenLoc && tokenLoc.r || 0) + 1;
    throw new Error("Parse error on line " + line + ": expected '" + tag + "', got " + got);
  }
  const val = tokenText;
  advance();
  return val;
}

function match(tag) {
  if (token === tag) {
    const val = tokenText;
    advance();
    return val;
  }
}

function loc() {
  return tokenLoc ? { r: tokenLoc.r, c: tokenLoc.c } : { r: 0, c: 0 };
}

function withLoc(node, l) {
  if (Array.isArray(node)) node.loc = l || loc();
  return node;
}

function mark() {
  return { pos: lexerAdapter.pos, token, tokenText, tokenLoc: tokenLoc ? { r: tokenLoc.r, c: tokenLoc.c } : {} };
}

function reset(saved) {
  lexerAdapter.pos = saved.pos;
  token = saved.token;
  tokenText = saved.tokenText;
  tokenLoc = saved.tokenLoc;
}

function speculate(fn) {
  const saved = mark();
  try { return fn(); }
  catch (e) { reset(saved); return null; }
}

const BP = {};
BP["POST_IF"] = 2;
BP["IF"] = 4;
BP["ELSE"] = 4;
BP["FOR"] = 4;
BP["WHILE"] = 4;
BP["UNTIL"] = 4;
BP["LOOP"] = 4;
BP["SUPER"] = 4;
BP["CLASS"] = 4;
BP["COMPONENT"] = 4;
BP["RENDER"] = 4;
BP["IMPORT"] = 4;
BP["EXPORT"] = 4;
BP["DYNAMIC_IMPORT"] = 4;
BP["FORIN"] = 6;
BP["FOROF"] = 6;
BP["FORAS"] = 6;
BP["FORASAWAIT"] = 6;
BP["BY"] = 6;
BP["WHEN"] = 6;
BP["="] = 8;
BP[":"] = 8;
BP["COMPOUND_ASSIGN"] = 8;
BP["RETURN"] = 8;
BP["THROW"] = 8;
BP["EXTENDS"] = 8;
BP["YIELD"] = 10;
BP["INDENT"] = 12;
BP["OUTDENT"] = 12;
BP["SPACE?"] = 14;
BP["PIPE"] = 16;
BP["||"] = 18;
BP["&&"] = 20;
BP["|"] = 22;
BP["^"] = 24;
BP["&"] = 26;
BP["COMPARE"] = 28;
BP["RELATION"] = 30;
BP["SHIFT"] = 32;
BP["+"] = 34;
BP["-"] = 34;
BP["MATH"] = 36;
BP["UNARY_MATH"] = 38;
BP["**"] = 40;
BP["AWAIT"] = 42;
BP["UNARY"] = 44;
BP["DO"] = 44;
BP["++"] = 46;
BP["--"] = 46;
BP["?"] = 46;
BP["CALL_START"] = 48;
BP["CALL_END"] = 48;
BP["."] = 50;
BP["?."] = 50;
BP["DO_IIFE"] = 52;

function parseUnary() {
  const l = loc();
  // Prefix operators (derived from Operation rules)
  if (token === "UNARY") {
    const _op = tokenText; advance();
    const expr = parseExpression(44);
    const _vals_ = [_op, expr];
    const $ = _vals_, $0 = 1;
    const _r = ruleActions(370, _vals_, [], {});
    return _r != null ? withLoc(_r, l) : expr;
  }
  if (token === "DO") {
    advance();
    const expr = parseExpression(44);
    const _vals_ = ["DO", expr];
    const $ = _vals_, $0 = 1;
    const _r = ruleActions(371, _vals_, [], {});
    return _r != null ? withLoc(_r, l) : expr;
  }
  if (token === "UNARY_MATH") {
    const _op = tokenText; advance();
    const expr = parseExpression(38);
    const _vals_ = [_op, expr];
    const $ = _vals_, $0 = 1;
    const _r = ruleActions(372, _vals_, [], {});
    return _r != null ? withLoc(_r, l) : expr;
  }
  if (token === "-") {
    advance();
    const expr = parseExpression(38);
    const _vals_ = ["-", expr];
    const $ = _vals_, $0 = 1;
    const _r = ruleActions(373, _vals_, [], {});
    return _r != null ? withLoc(_r, l) : expr;
  }
  if (token === "+") {
    advance();
    const expr = parseExpression(38);
    const _vals_ = ["+", expr];
    const $ = _vals_, $0 = 1;
    const _r = ruleActions(374, _vals_, [], {});
    return _r != null ? withLoc(_r, l) : expr;
  }
  if (token === "AWAIT") {
    const _op = tokenText; advance();
    const expr = parseExpression(42);
    const _vals_ = [_op, expr];
    const $ = _vals_, $0 = 1;
    const _r = ruleActions(376, _vals_, [], {});
    return _r != null ? withLoc(_r, l) : expr;
  }
  if (token === "--") {
    advance();
    const expr = parseSimpleAssignable();
    const _vals_ = ["--", expr];
    const $ = _vals_, $0 = 1;
    const _r = ruleActions(378, _vals_, [], {});
    return _r != null ? withLoc(_r, l) : expr;
  }
  if (token === "++") {
    advance();
    const expr = parseSimpleAssignable();
    const _vals_ = ["++", expr];
    const $ = _vals_, $0 = 1;
    const _r = ruleActions(379, _vals_, [], {});
    return _r != null ? withLoc(_r, l) : expr;
  }
  // Atoms (derived from Value/Literal rules)
  if (token === '[') {
    const _range = speculate(() => parseRange());
    if (_range !== null) return _range;
    return parseArray();
  }
  if (token === '@') {
    const _saved = mark(); advance();
    if (token === 'PROPERTY') { reset(_saved); return parseThisProperty(); }
    reset(_saved); return parseThis();
  }
  if (token === 'SUPER') {
    const _saved = mark(); advance();
    if (token === '.' || token === 'INDEX_START') { reset(_saved); return parseSuper(); }
    reset(_saved); return parseInvocation();
  }
  if (token === "IDENTIFIER") {
    const _vals_ = [tokenText]; advance();
    const $ = _vals_, $0 = 0;
    const _r = ruleActions(54, _vals_, [], {});
    return _r != null ? _r : _vals_[0];
  }
  if (token === "{") return parseObject();
  if (token === "NUMBER") {
    const _vals_ = [tokenText]; advance();
    const $ = _vals_, $0 = 0;
    const _r = ruleActions(52, _vals_, [], {});
    return _r != null ? _r : _vals_[0];
  }
  if (token === "STRING") {
    const _vals_ = [tokenText]; advance();
    const $ = _vals_, $0 = 0;
    const _r = ruleActions(56, _vals_, [], {});
    return _r != null ? _r : _vals_[0];
  }
  if (token === "STRING_START") return parseString();
  if (token === "JS") {
    const _vals_ = [tokenText]; advance();
    const $ = _vals_, $0 = 0;
    const _r = ruleActions(45, _vals_, [], {});
    return _r != null ? _r : _vals_[0];
  }
  if (token === "REGEX") {
    const _vals_ = [tokenText]; advance();
    const $ = _vals_, $0 = 0;
    const _r = ruleActions(64, _vals_, [], {});
    return _r != null ? _r : _vals_[0];
  }
  if (token === "REGEX_START") return parseRegex();
  if (token === "UNDEFINED") {
    const _vals_ = [tokenText]; advance();
    const $ = _vals_, $0 = 0;
    const _r = ruleActions(47, _vals_, [], {});
    return _r != null ? _r : _vals_[0];
  }
  if (token === "NULL") {
    const _vals_ = [tokenText]; advance();
    const $ = _vals_, $0 = 0;
    const _r = ruleActions(48, _vals_, [], {});
    return _r != null ? _r : _vals_[0];
  }
  if (token === "BOOL") {
    const _vals_ = [tokenText]; advance();
    const $ = _vals_, $0 = 0;
    const _r = ruleActions(49, _vals_, [], {});
    return _r != null ? _r : _vals_[0];
  }
  if (token === "INFINITY") {
    const _vals_ = [tokenText]; advance();
    const $ = _vals_, $0 = 0;
    const _r = ruleActions(50, _vals_, [], {});
    return _r != null ? _r : _vals_[0];
  }
  if (token === "NAN") {
    const _vals_ = [tokenText]; advance();
    const $ = _vals_, $0 = 0;
    const _r = ruleActions(51, _vals_, [], {});
    return _r != null ? _r : _vals_[0];
  }
  if (token === "(") return parseParenthetical();
  if (token === "DYNAMIC_IMPORT") return parseInvocation();
  if (token === "DO_IIFE") return parseDoIife();
  if (token === "THIS") {
    const _vals_ = [tokenText]; advance();
    const $ = _vals_, $0 = 0;
    const _r = ruleActions(205, _vals_, [], {});
    return _r != null ? _r : _vals_[0];
  }
  if (token === "NEW_TARGET") return parseMetaProperty();
  if (token === "IMPORT_META") return parseMetaProperty();
  if (token === "PARAM_START") return parseAssignable();
  if (token === "->") return parseAssignable();
  if (token === "=>") return parseAssignable();
  if (token === "PARAM_START") return parseInvocation();
  if (token === "->") return parseInvocation();
  if (token === "=>") return parseInvocation();
  if (token === "PARAM_START") return parseCode();
  if (token === "->") return parseCode();
  if (token === "=>") return parseCode();
  if (token === '...') return parseSplat();
  if (token === 'STATEMENT') { const v = tokenText; advance(); return v; }
  if (token === 'RETURN') return parseReturn();
  if (token === 'REACT_ASSIGN') return parseReactAssign();
  throw new Error('Parse error: unexpected token ' + token + ' at line ' + ((tokenLoc && tokenLoc.r || 0) + 1));
}

function parsePostfixFor(expr, l) {
  advance(); // consume FOR
  if (token === 'AWAIT') {
    advance();
    const vars = parseForVariables();
    if (token === 'FORAS') {
      advance();
      const iter = parseExpression(0);
      const guard = token === 'WHEN' ? (advance(), parseExpression(0)) : null;
      return withLoc(["comprehension", expr, [["for-as", vars, iter, true, null]], guard ? [guard] : []], l);
    }
  }
  if (token === 'OWN') {
    advance();
    const vars = parseForVariables();
    expect('FOROF');
    const obj = parseExpression(0);
    const guard = token === 'WHEN' ? (advance(), parseExpression(0)) : null;
    return withLoc(["comprehension", expr, [["for-of", vars, obj, true]], guard ? [guard] : []], l);
  }
  if (token === '[') {
    const range = speculate(() => parseRange());
    if (range !== null) {
      if (token === 'BY') { advance(); const step = parseExpression(0); return withLoc(["comprehension", expr, [["for-in", [], range, step]], []], l); }
      return withLoc(["comprehension", expr, [["for-in", [], range, null]], []], l);
    }
  }
  const vars = parseForVariables();
  if (token === 'FORIN') {
    advance(); const arr = parseExpression(0);
    let step = null, guard = null;
    if (token === 'WHEN') { advance(); guard = parseExpression(0); }
    if (token === 'BY') { advance(); step = parseExpression(0); }
    if (!guard && token === 'WHEN') { advance(); guard = parseExpression(0); }
    return withLoc(["comprehension", expr, [["for-in", vars, arr, step]], guard ? [guard] : []], l);
  }
  if (token === 'FOROF') {
    advance(); const obj = parseExpression(0);
    const guard = token === 'WHEN' ? (advance(), parseExpression(0)) : null;
    return withLoc(["comprehension", expr, [["for-of", vars, obj, false]], guard ? [guard] : []], l);
  }
  if (token === 'FORAS' || token === 'FORASAWAIT') {
    const isAsync = token === 'FORASAWAIT'; advance();
    const iter = parseExpression(0);
    const guard = token === 'WHEN' ? (advance(), parseExpression(0)) : null;
    return withLoc(["comprehension", expr, [["for-as", vars, iter, isAsync, null]], guard ? [guard] : []], l);
  }
  throw new Error('Parse error in postfix for: unexpected ' + token);
}

function parseRoot() {
  if (token === EOF) return withLoc(["program"]);
  const body = parseBody();
  return withLoc(["program", ...body]);
}

function parseBody() {
  const items = [parseLine()];
  while (token === 'TERMINATOR') {
    advance();
    if (token !== EOF && token !== 'OUTDENT') {
      items.push(parseLine());
    }
  }
  return items;
}

function parseLine() {
  if (token === "IMPORT" || token === "EXPORT") return parseStatement();
  return parseExpression();
}

function parseStatement() {
  if (token === "STATEMENT") {
    const v = tokenText; advance(); return v;
  }
  if (token === "RETURN") return parseReturn();
  if (token === "IMPORT") return parseImport();
  return parseExport();
}

function parseExpression(minBP) {
  if (minBP === undefined) minBP = 0;
  const l = loc();

  // Statement-like expression starters (derived from Expression alternatives)
  if (token === "IF") return parseIf();
  if (token === "UNLESS") return parseIf();
  if (token === "TRY") return parseTry();
  if (token === "WHILE") return parseWhile();
  if (token === "UNTIL") return parseWhile();
  if (token === "LOOP") return parseWhile();
  if (token === "FOR") return parseFor();
  if (token === "SWITCH") return parseSwitch();
  if (token === "CLASS") return parseClass();
  if (token === "COMPONENT") return parseComponent();
  if (token === "RENDER") return parseRender();
  if (token === "THROW") return parseThrow();
  if (token === "YIELD") return parseYield();
  if (token === "DEF") return parseDef();
  if (token === "ENUM") return parseEnum();

  // Arrow functions
  if (token === "PARAM_START" || token === "->" || token === "=>") return parseCode();

  // Pratt expression parser
  let left = parseUnary();

  while (true) {
    // Assignment operators (derived from grammar rules)
    if (minBP === 0) {
      if (token === "=") {
        const _op = tokenText; advance();
        let right;
        if (token === 'TERMINATOR') { advance(); right = parseExpression(0); }
        else if (token === 'INDENT') { advance(); right = parseExpression(0); expect('OUTDENT'); }
        else { right = parseExpression(0); }
        const _vals_ = [left, _op, right];
        const $ = _vals_, $0 = _vals_.length - 1;
        const _r = ruleActions(68, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : withLoc(left, l);
        continue;
      }
      if (token === "REACTIVE_ASSIGN") {
        const _op = tokenText; advance();
        let right;
        if (token === 'TERMINATOR') { advance(); right = parseExpression(0); }
        else if (token === 'INDENT') { advance(); right = parseExpression(0); expect('OUTDENT'); }
        else { right = parseExpression(0); }
        const _vals_ = [left, _op, right];
        const $ = _vals_, $0 = _vals_.length - 1;
        const _r = ruleActions(71, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : withLoc(left, l);
        continue;
      }
      if (token === "COMPUTED_ASSIGN") {
        const _op = tokenText; advance();
        let right;
        if (token === 'TERMINATOR') { advance(); right = parseExpression(0); }
        else if (token === 'INDENT') { advance(); right = parseExpression(0); expect('OUTDENT'); }
        else { right = parseExpression(0); }
        const _vals_ = [left, _op, right];
        const $ = _vals_, $0 = _vals_.length - 1;
        const _r = ruleActions(74, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : withLoc(left, l);
        continue;
      }
      if (token === "READONLY_ASSIGN") {
        const _op = tokenText; advance();
        let right;
        if (token === 'TERMINATOR') { advance(); right = parseExpression(0); }
        else if (token === 'INDENT') { advance(); right = parseExpression(0); expect('OUTDENT'); }
        else { right = parseExpression(0); }
        const _vals_ = [left, _op, right];
        const $ = _vals_, $0 = _vals_.length - 1;
        const _r = ruleActions(77, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : withLoc(left, l);
        continue;
      }
      if (token === "REACT_ASSIGN") {
        const _op = tokenText; advance();
        let right;
        if (token === 'TERMINATOR') { advance(); right = parseExpression(0); }
        else if (token === 'INDENT') { advance(); right = parseExpression(0); expect('OUTDENT'); }
        else { right = parseExpression(0); }
        const _vals_ = [left, _op, right];
        const $ = _vals_, $0 = _vals_.length - 1;
        const _r = ruleActions(80, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : withLoc(left, l);
        continue;
      }
    }

    // Postfix operators (derived from Operation rules)
    if (token === "?" && (BP["?"] || 0) >= minBP) {
      const _vals_ = [left];
      _vals_.push(expect("?"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(375, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "--" && (BP["--"] || 0) >= minBP) {
      const _vals_ = [left];
      _vals_.push(expect("--"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(380, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "++" && (BP["++"] || 0) >= minBP) {
      const _vals_ = [left];
      _vals_.push(expect("++"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(381, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "SPACE?" && (BP["SPACE?"] || 0) >= minBP) {
      const _vals_ = [left];
      _vals_.push(expect("SPACE?"));
      _vals_.push(parseExpression());
      _vals_.push(expect(":"));
      _vals_.push(parseExpression());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(403, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }

    // Postfix chains (derived from SimpleAssignable/Invocation rules)
    if (token === "STRING") {
      const _vals_ = [left];
      _vals_.push(parseString());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(187, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "STRING_START") {
      const _vals_ = [left];
      _vals_.push(parseString());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(187, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "CALL_START" && (BP["CALL_START"] || 0) >= minBP) {
      const _vals_ = [left];
      _vals_.push(parseArguments());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(188, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "ES6_OPTIONAL_CALL") {
      const _vals_ = [left];
      _vals_.push(expect("ES6_OPTIONAL_CALL"));
      _vals_.push(parseArguments());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(189, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "." && (BP["."] || 0) >= minBP) {
      const _vals_ = [left];
      _vals_.push(expect("."));
      _vals_.push(parseProperty());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(91, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "?." && (BP["?."] || 0) >= minBP) {
      const _vals_ = [left];
      _vals_.push(expect("?."));
      _vals_.push(parseProperty());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(92, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "INDEX_START") {
      const _vals_ = [left];
      _vals_.push(expect("INDEX_START"));
      if (token === '..' || token === '...') {
        const _slice = parseRangeDots();
        if (token !== 'INDEX_END') { _vals_.push([_slice, null, parseExpression()]); }
        else { _vals_.push([_slice, null, null]); }
        _vals_.push(expect('INDEX_END'));
        const $ = _vals_, $0 = _vals_.length - 1;
        const _r = ruleActions(95, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : left; continue;
      }
      const _expr = parseExpression();
      if (token === '..' || token === '...') {
        const _dots = parseRangeDots();
        if (token !== 'INDEX_END') {
          _vals_.push([_dots, _expr, parseExpression()]);
        } else {
          _vals_.push([_dots, _expr, null]);
        }
        _vals_.push(expect('INDEX_END'));
        const $ = _vals_, $0 = _vals_.length - 1;
        const _r = ruleActions(95, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : left;
      } else {
        _vals_.push(_expr);
        _vals_.push(expect('INDEX_END'));
        const $ = _vals_, $0 = _vals_.length - 1;
        const _r = ruleActions(93, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : left;
      }
      continue;
    }
    if (token === "ES6_OPTIONAL_INDEX") {
      const _vals_ = [left];
      _vals_.push(expect("ES6_OPTIONAL_INDEX"));
      _vals_.push(expect("INDEX_START"));
      if (token === "INDENT") {
        _vals_.push(expect("INDENT"));
        _vals_.push(parseExpression());
        _vals_.push(expect("OUTDENT"));
        _vals_.push(expect("INDEX_END"));
        const $ = _vals_, $0 = _vals_.length - 1;
        const _r = ruleActions(99, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : left;
      }
      else if (token === "IDENTIFIER" || token === "@" || token === "[" || token === "{" || token === "NUMBER" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "PARAM_START" || token === "->" || token === "=>" || token === "STRING" || token === "STRING_START" || token === "UNARY" || token === "DO" || token === "UNARY_MATH" || token === "-" || token === "+" || token === "AWAIT" || token === "--" || token === "++" || token === "REACT_ASSIGN" || token === "TRY" || token === "FOR" || token === "SWITCH" || token === "CLASS" || token === "COMPONENT" || token === "RENDER" || token === "THROW" || token === "YIELD" || token === "DEF" || token === "ENUM" || token === "IF" || token === "UNLESS" || token === "RETURN" || token === "STATEMENT" || token === "IMPORT" || token === "EXPORT" || token === "WHILE" || token === "UNTIL" || token === "LOOP") {
        _vals_.push(parseExpression());
        _vals_.push(expect("INDEX_END"));
        const $ = _vals_, $0 = _vals_.length - 1;
        const _r = ruleActions(98, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : left;
      }
      continue;
    }

    // Binary operators (derived from Operation rules)
    if (token === "+" && (BP["+"] || 0) >= minBP) {
      advance();
      const right = parseExpression((BP["+"] || 0) + 1);
      const _vals_ = [left, "+", right];
      const $ = _vals_, $0 = 2;
      const _r = ruleActions(382, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "-" && (BP["-"] || 0) >= minBP) {
      advance();
      const right = parseExpression((BP["-"] || 0) + 1);
      const _vals_ = [left, "-", right];
      const $ = _vals_, $0 = 2;
      const _r = ruleActions(383, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "MATH" && (BP["MATH"] || 0) >= minBP) {
      const _op = tokenText; advance();
      const right = parseExpression((BP["MATH"] || 0) + 1);
      const _vals_ = [left, _op, right];
      const $ = _vals_, $0 = 2;
      const _r = ruleActions(384, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "**" && (BP["**"] || 0) >= minBP) {
      advance();
      const right = parseExpression((BP["**"] || 0));
      const _vals_ = [left, "**", right];
      const $ = _vals_, $0 = 2;
      const _r = ruleActions(385, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "SHIFT" && (BP["SHIFT"] || 0) >= minBP) {
      const _op = tokenText; advance();
      const right = parseExpression((BP["SHIFT"] || 0) + 1);
      const _vals_ = [left, _op, right];
      const $ = _vals_, $0 = 2;
      const _r = ruleActions(386, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "COMPARE" && (BP["COMPARE"] || 0) >= minBP) {
      const _op = tokenText; advance();
      const right = parseExpression((BP["COMPARE"] || 0) + 1);
      const _vals_ = [left, _op, right];
      const $ = _vals_, $0 = 2;
      const _r = ruleActions(387, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "&" && (BP["&"] || 0) >= minBP) {
      advance();
      const right = parseExpression((BP["&"] || 0) + 1);
      const _vals_ = [left, "&", right];
      const $ = _vals_, $0 = 2;
      const _r = ruleActions(388, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "^" && (BP["^"] || 0) >= minBP) {
      advance();
      const right = parseExpression((BP["^"] || 0) + 1);
      const _vals_ = [left, "^", right];
      const $ = _vals_, $0 = 2;
      const _r = ruleActions(389, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "|" && (BP["|"] || 0) >= minBP) {
      advance();
      const right = parseExpression((BP["|"] || 0) + 1);
      const _vals_ = [left, "|", right];
      const $ = _vals_, $0 = 2;
      const _r = ruleActions(390, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "||" && (BP["||"] || 0) >= minBP) {
      advance();
      if (token === "RETURN") {
        const ctrl = parseReturn();
        const _vals_ = [left, "||", ctrl];
        const $ = _vals_, $0 = 2;
        const _r = ruleActions(391, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : left; continue;
      }
      else if (token === "THROW") {
        const ctrl = parseThrow();
        const _vals_ = [left, "||", ctrl];
        const $ = _vals_, $0 = 2;
        const _r = ruleActions(392, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : left; continue;
      }
      else {
        const right = parseExpression((BP["||"] || 0) + 1);
        const _vals_ = [left, "||", right];
        const $ = _vals_, $0 = 2;
        const _r = ruleActions(398, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : left; continue;
      }
    }
    if (token === "??" && (BP["??"] || 0) >= minBP) {
      advance();
      if (token === "RETURN") {
        const ctrl = parseReturn();
        const _vals_ = [left, "??", ctrl];
        const $ = _vals_, $0 = 2;
        const _r = ruleActions(393, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : left; continue;
      }
      else if (token === "THROW") {
        const ctrl = parseThrow();
        const _vals_ = [left, "??", ctrl];
        const $ = _vals_, $0 = 2;
        const _r = ruleActions(394, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : left; continue;
      }
      else {
        const right = parseExpression((BP["??"] || 0) + 1);
        const _vals_ = [left, "??", right];
        const $ = _vals_, $0 = 2;
        const _r = ruleActions(399, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : left; continue;
      }
    }
    if (token === "&&" && (BP["&&"] || 0) >= minBP) {
      advance();
      if (token === "RETURN") {
        const ctrl = parseReturn();
        const _vals_ = [left, "&&", ctrl];
        const $ = _vals_, $0 = 2;
        const _r = ruleActions(395, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : left; continue;
      }
      else if (token === "THROW") {
        const ctrl = parseThrow();
        const _vals_ = [left, "&&", ctrl];
        const $ = _vals_, $0 = 2;
        const _r = ruleActions(396, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : left; continue;
      }
      else {
        const right = parseExpression((BP["&&"] || 0) + 1);
        const _vals_ = [left, "&&", right];
        const $ = _vals_, $0 = 2;
        const _r = ruleActions(397, _vals_, [], {});
        left = _r != null ? withLoc(_r, l) : left; continue;
      }
    }
    if (token === "!?" && (BP["!?"] || 0) >= minBP) {
      advance();
      const right = parseExpression((BP["!?"] || 0) + 1);
      const _vals_ = [left, "!?", right];
      const $ = _vals_, $0 = 2;
      const _r = ruleActions(400, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "PIPE" && (BP["PIPE"] || 0) >= minBP) {
      const _op = tokenText; advance();
      const right = parseExpression((BP["PIPE"] || 0) + 1);
      const _vals_ = [left, _op, right];
      const $ = _vals_, $0 = 2;
      const _r = ruleActions(401, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "RELATION" && (BP["RELATION"] || 0) >= minBP) {
      const _op = tokenText; advance();
      const right = parseExpression((BP["RELATION"] || 0) + 1);
      const _vals_ = [left, _op, right];
      const $ = _vals_, $0 = 2;
      const _r = ruleActions(402, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }
    if (token === "COMPOUND_ASSIGN" && (BP["COMPOUND_ASSIGN"] || 0) >= minBP) {
      const _op = tokenText; advance();
      let right;
      if (token === 'TERMINATOR') { advance(); right = parseExpression((BP["COMPOUND_ASSIGN"] || 0)); }
      else if (token === 'INDENT') { advance(); right = parseExpression((BP["COMPOUND_ASSIGN"] || 0)); expect('OUTDENT'); }
      else { right = parseExpression((BP["COMPOUND_ASSIGN"] || 0)); }
      const _vals_ = [left, _op, right];
      const $ = _vals_, $0 = 2;
      const _r = ruleActions(404, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }

    // Postfix POST_IF (derived from If rules)
    if (token === "POST_IF" && 2 >= minBP) {
      const _pvals_ = [left];
      _pvals_.push(expect("POST_IF"));
      _pvals_.push(parseExpression());
      if (token === "ELSE") {
        _pvals_.push(expect("ELSE"));
        _pvals_.push(expect("INDENT"));
        _pvals_.push(parseExpression());
        _pvals_.push(expect("OUTDENT"));
        const $ = _pvals_, $0 = _pvals_.length - 1;
        const _r = ruleActions(237, _pvals_, [], {});
        left = _r != null ? withLoc(_r, l) : left; continue;
      }
      const $ = _pvals_, $0 = _pvals_.length - 1;
      const _r = ruleActions(235, _pvals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }

    // Postfix POST_UNLESS (derived from If rules)
    if (token === "POST_UNLESS" && 0 >= minBP) {
      const _pvals_ = [left];
      _pvals_.push(expect("POST_UNLESS"));
      _pvals_.push(parseExpression());
      const $ = _pvals_, $0 = _pvals_.length - 1;
      const _r = ruleActions(238, _pvals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }

    // Postfix WHILE (derived from While via WhileSource)
    if (token === "WHILE" && minBP === 0) {
      const _ws = parseWhileSource();
      const _vals_ = [left, _ws];
      const $ = _vals_, $0 = 1;
      const _r = ruleActions(261, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }

    // Postfix UNTIL (derived from While via WhileSource)
    if (token === "UNTIL" && minBP === 0) {
      const _ws = parseWhileSource();
      const _vals_ = [left, _ws];
      const $ = _vals_, $0 = 1;
      const _r = ruleActions(261, _vals_, [], {});
      left = _r != null ? withLoc(_r, l) : left;
      continue;
    }

    // Postfix FOR (derived from For rules)
    if (token === "FOR" && minBP === 0) {
      left = parsePostfixFor(left, l);
      continue;
    }

    break;
  }
  return left;
}

function parseExpressionLine() {
  if (token === "PARAM_START" || token === "->" || token === "=>") return parseCodeLine();
  return parseOperationLine();
}

function parseValue() {
  if (token === "(") return parseParenthetical();
  if (token === "[") return parseRange();
  if (token === "DO_IIFE") return parseDoIife();
  if (token === "SUPER") return parseSuper();
  if (token === "THIS" || token === "@") return parseThis();
  if (token === "NEW_TARGET" || token === "IMPORT_META") return parseMetaProperty();
  if (token === "NUMBER" || token === "STRING" || token === "STRING_START" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN") return parseLiteral();
  if (token === "IDENTIFIER" || token === "DYNAMIC_IMPORT" || token === "PARAM_START" || token === "->" || token === "=>" || token === "{") return parseAssignable();
  return parseInvocation();
}

function parseLiteral() {
  if (token === "JS") {
    const v = tokenText; advance(); return v;
  }
  if (token === "UNDEFINED") {
    const v = tokenText; advance(); return v;
  }
  if (token === "NULL") {
    const v = tokenText; advance(); return v;
  }
  if (token === "BOOL") {
    const v = tokenText; advance(); return v;
  }
  if (token === "INFINITY") {
    const v = tokenText; advance(); return v;
  }
  if (token === "NAN") {
    const v = tokenText; advance(); return v;
  }
  if (token === "REGEX" || token === "REGEX_START") return parseRegex();
  return parseAlphaNumeric();
}

function parseAlphaNumeric() {
  if (token === "NUMBER") {
    const v = tokenText; advance(); return v;
  }
  return parseString();
}

function parseIdentifier() {
  return expect("IDENTIFIER");
}

function parseProperty() {
  return expect("PROPERTY");
}

function parseString() {
  const l = loc();
  if (token === "STRING") {
    const _vals_ = [];
    _vals_.push(expect("STRING"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(56, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else if (token === "STRING_START") {
    const _vals_ = [];
    _vals_.push(expect("STRING_START"));
    _vals_.push(parseInterpolations());
    _vals_.push(expect("STRING_END"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(57, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in String');
  }
}

function parseInterpolations() {
  const items = [parseInterpolationChunk()];
  while (token === "INTERPOLATION_START" || token === "STRING" || token === "STRING_START") {
    items.push(parseInterpolationChunk());
  }
  return items;
}

function parseInterpolationChunk() {
  if (token === "INTERPOLATION_START") {
    const l = loc();
    const _vals_ = [];
    _vals_.push(expect("INTERPOLATION_START"));
    _vals_.push(parseBody());
    _vals_.push(expect("INTERPOLATION_END"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(60, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  if (token === "INTERPOLATION_START") {
    const l = loc();
    const _vals_ = [];
    _vals_.push(expect("INTERPOLATION_START"));
    _vals_.push(expect("INDENT"));
    _vals_.push(parseBody());
    _vals_.push(expect("OUTDENT"));
    _vals_.push(expect("INTERPOLATION_END"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(61, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  if (token === "INTERPOLATION_START") {
    const l = loc();
    const _vals_ = [];
    _vals_.push(expect("INTERPOLATION_START"));
    _vals_.push(expect("INTERPOLATION_END"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(62, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  return parseString();
}

function parseRegex() {
  const l = loc();
  if (token === "REGEX") {
    const _vals_ = [];
    _vals_.push(expect("REGEX"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(64, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else if (token === "REGEX_START") {
    const _vals_ = [];
    _vals_.push(expect("REGEX_START"));
    _vals_.push(parseInvocation());
    _vals_.push(expect("REGEX_END"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(65, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Regex');
  }
}

function parseRegexWithIndex() {
  const l = loc();
  const _vals_ = [];
  _vals_.push(parseRegex());
  if (token === ",") {
    _vals_.push(expect(","));
    _vals_.push(parseExpression());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(66, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(67, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
}

function parseAssign() {
  const l = loc();
  const _vals_ = [];
  _vals_.push(parseAssignable());
  _vals_.push(expect("="));
  if (token === "INDENT") {
    _vals_.push(expect("INDENT"));
    _vals_.push(parseExpression());
    _vals_.push(expect("OUTDENT"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(70, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else if (token === "TERMINATOR") {
    _vals_.push(expect("TERMINATOR"));
    _vals_.push(parseExpression());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(69, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    _vals_.push(parseExpression());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(68, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
}

function parseReactiveAssign() {
  const l = loc();
  const _vals_ = [];
  _vals_.push(parseAssignable());
  _vals_.push(expect("REACTIVE_ASSIGN"));
  if (token === "INDENT") {
    _vals_.push(expect("INDENT"));
    _vals_.push(parseExpression());
    _vals_.push(expect("OUTDENT"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(73, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else if (token === "TERMINATOR") {
    _vals_.push(expect("TERMINATOR"));
    _vals_.push(parseExpression());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(72, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    _vals_.push(parseExpression());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(71, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
}

function parseComputedAssign() {
  const l = loc();
  const _vals_ = [];
  _vals_.push(parseAssignable());
  _vals_.push(expect("COMPUTED_ASSIGN"));
  if (token === "INDENT") {
    _vals_.push(expect("INDENT"));
    _vals_.push(parseExpression());
    _vals_.push(expect("OUTDENT"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(76, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else if (token === "TERMINATOR") {
    _vals_.push(expect("TERMINATOR"));
    _vals_.push(parseExpression());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(75, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    _vals_.push(parseExpression());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(74, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
}

function parseReadonlyAssign() {
  const l = loc();
  const _vals_ = [];
  _vals_.push(parseAssignable());
  _vals_.push(expect("READONLY_ASSIGN"));
  if (token === "INDENT") {
    _vals_.push(expect("INDENT"));
    _vals_.push(parseExpression());
    _vals_.push(expect("OUTDENT"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(79, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else if (token === "TERMINATOR") {
    _vals_.push(expect("TERMINATOR"));
    _vals_.push(parseExpression());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(78, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    _vals_.push(parseExpression());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(77, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
}

function parseReactAssign() {
  const l = loc();
  if (token === "REACT_ASSIGN") {
    const _vals_ = [];
    _vals_.push(expect("REACT_ASSIGN"));
    if (token === "INDENT") {
      _vals_.push(expect("INDENT"));
      _vals_.push(parseExpression());
      _vals_.push(expect("OUTDENT"));
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(85, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else if (token === "TERMINATOR") {
      _vals_.push(expect("TERMINATOR"));
      _vals_.push(parseExpression());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(84, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      _vals_.push(parseExpression());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(83, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else {
    const _vals_ = [];
    _vals_.push(parseAssignable());
    _vals_.push(expect("REACT_ASSIGN"));
    if (token === "INDENT") {
      _vals_.push(expect("INDENT"));
      _vals_.push(parseExpression());
      _vals_.push(expect("OUTDENT"));
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(82, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else if (token === "TERMINATOR") {
      _vals_.push(expect("TERMINATOR"));
      _vals_.push(parseExpression());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(81, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      _vals_.push(parseExpression());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(80, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
}

function parseAssignable() {
  if (token === "[") return parseArray();
  if (token === "{") return parseObject();
  return parseSimpleAssignable();
}

function parseSimpleAssignable() {
  if (token === "IDENTIFIER") return parseIdentifier();
  if (token === "@") return parseThisProperty();
  if (token === "PARAM_START" || token === "->" || token === "=>") {
    const l = loc();
    let _node_ = parseCode();
    if (token === ".") {
      const _vals_ = [_node_];
      _vals_.push(expect("."));
      _vals_.push(parseProperty());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(100, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "?.") {
      const _vals_ = [_node_];
      _vals_.push(expect("?."));
      _vals_.push(parseProperty());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(101, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "INDEX_START") {
      const _vals_ = [_node_];
      _vals_.push(expect("INDEX_START"));
      _vals_.push(parseExpression());
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(102, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "INDEX_START") {
      const _vals_ = [_node_];
      _vals_.push(expect("INDEX_START"));
      _vals_.push(expect("INDENT"));
      _vals_.push(parseExpression());
      _vals_.push(expect("OUTDENT"));
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(103, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    return _node_;
  }
  if (token === "[" || token === "{" || token === "NUMBER" || token === "STRING" || token === "STRING_START" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META") {
    const l = loc();
    let _node_ = parseValue();
    if (token === ".") {
      const _vals_ = [_node_];
      _vals_.push(expect("."));
      _vals_.push(parseProperty());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(91, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "?.") {
      const _vals_ = [_node_];
      _vals_.push(expect("?."));
      _vals_.push(parseProperty());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(92, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "INDEX_START") {
      const _vals_ = [_node_];
      _vals_.push(expect("INDEX_START"));
      _vals_.push(parseExpression());
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(93, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "INDEX_START") {
      const _vals_ = [_node_];
      _vals_.push(expect("INDEX_START"));
      _vals_.push(expect("INDENT"));
      _vals_.push(parseExpression());
      _vals_.push(expect("OUTDENT"));
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(94, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "INDEX_START") {
      const _vals_ = [_node_];
      _vals_.push(expect("INDEX_START"));
      _vals_.push(parseSlice());
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(95, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "INDEX_START") {
      const _vals_ = [_node_];
      _vals_.push(expect("INDEX_START"));
      _vals_.push(expect("INDENT"));
      _vals_.push(parseSlice());
      _vals_.push(expect("OUTDENT"));
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(96, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "INDEX_START") {
      const _vals_ = [_node_];
      _vals_.push(expect("INDEX_START"));
      _vals_.push(parseRegexWithIndex());
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(97, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "ES6_OPTIONAL_INDEX") {
      const _vals_ = [_node_];
      _vals_.push(expect("ES6_OPTIONAL_INDEX"));
      _vals_.push(expect("INDEX_START"));
      _vals_.push(parseExpression());
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(98, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "ES6_OPTIONAL_INDEX") {
      const _vals_ = [_node_];
      _vals_.push(expect("ES6_OPTIONAL_INDEX"));
      _vals_.push(expect("INDEX_START"));
      _vals_.push(expect("INDENT"));
      _vals_.push(parseExpression());
      _vals_.push(expect("OUTDENT"));
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(99, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    return _node_;
  }
  {
    const l = loc();
    let _node_ = parseValue();
    if (token === ".") {
      const _vals_ = [_node_];
      _vals_.push(expect("."));
      _vals_.push(parseProperty());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(91, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "?.") {
      const _vals_ = [_node_];
      _vals_.push(expect("?."));
      _vals_.push(parseProperty());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(92, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "INDEX_START") {
      const _vals_ = [_node_];
      _vals_.push(expect("INDEX_START"));
      _vals_.push(parseExpression());
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(93, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "INDEX_START") {
      const _vals_ = [_node_];
      _vals_.push(expect("INDEX_START"));
      _vals_.push(expect("INDENT"));
      _vals_.push(parseExpression());
      _vals_.push(expect("OUTDENT"));
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(94, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "INDEX_START") {
      const _vals_ = [_node_];
      _vals_.push(expect("INDEX_START"));
      _vals_.push(parseSlice());
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(95, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "INDEX_START") {
      const _vals_ = [_node_];
      _vals_.push(expect("INDEX_START"));
      _vals_.push(expect("INDENT"));
      _vals_.push(parseSlice());
      _vals_.push(expect("OUTDENT"));
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(96, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "INDEX_START") {
      const _vals_ = [_node_];
      _vals_.push(expect("INDEX_START"));
      _vals_.push(parseRegexWithIndex());
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(97, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "ES6_OPTIONAL_INDEX") {
      const _vals_ = [_node_];
      _vals_.push(expect("ES6_OPTIONAL_INDEX"));
      _vals_.push(expect("INDEX_START"));
      _vals_.push(parseExpression());
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(98, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    if (token === "ES6_OPTIONAL_INDEX") {
      const _vals_ = [_node_];
      _vals_.push(expect("ES6_OPTIONAL_INDEX"));
      _vals_.push(expect("INDEX_START"));
      _vals_.push(expect("INDENT"));
      _vals_.push(parseExpression());
      _vals_.push(expect("OUTDENT"));
      _vals_.push(expect("INDEX_END"));
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(99, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    return _node_;
  }
}

function parseObject() {
  const l = loc();
  expect('{');
  // Empty object
  if (token === '}') {
    advance();
    return withLoc(["object"], l);
  }
  // Parse assign list (handles key: value pairs)
  const list = parseAssignList();
  match(',');
  // Check for comprehension (FOR after the first key:value)
  if (token === 'FOR') {
    // Object comprehension: {k: v for ...}
    // list should have [key, value, ":"] as first entry
    const first = list[0];
    const key = first ? first[0] : list[0];
    const val = first ? first[1] : list[1];
    advance(); // consume FOR
    if (token === 'OWN') {
      advance();
      const vars = parseForVariables();
      expect('FOROF');
      const obj = parseExpression(0);
      let guard = null;
      if (token === 'WHEN') { advance(); guard = parseExpression(0); }
      match(',');
      expect('}');
      return withLoc(["object-comprehension", key, val, [["for-of", vars, obj, true]], guard ? [guard] : []], l);
    }
    const vars = parseForVariables();
    if (token === 'FOROF') {
      advance();
      const obj = parseExpression(0);
      let guard = null;
      if (token === 'WHEN') { advance(); guard = parseExpression(0); }
      match(',');
      expect('}');
      return withLoc(["object-comprehension", key, val, [["for-of", vars, obj, false]], guard ? [guard] : []], l);
    }
    throw new Error('Parse error in Object comprehension: unexpected ' + token);
  }
  expect('}');
  return withLoc(["object", ...list], l);
}

function parseAssignList() {
  if (token === 'INDENT') {
    advance();
    const inner = parseAssignList();
    match(',');
    expect('OUTDENT');
    return inner;
  }
  const result = [parseAssignObj()];
  while (true) {
    if (token === ',') {
      advance();
      if (token === "OUTDENT") break;
      if (token === 'TERMINATOR') {
        advance();
        if (token === "OUTDENT") break;
      }
      result.push(parseAssignObj());
    } else if (token === 'TERMINATOR') {
      advance();
      if (token === "OUTDENT") break;
      result.push(parseAssignObj());
    } else if (token === 'INDENT') {
      advance();
      const inner = parseAssignList();
      match(',');
      expect('OUTDENT');
      result.push(...inner);
    } else {
      break;
    }
  }
  return result;
}

function parseAssignObj() {
  const l = loc();
  // Rest: {...x}
  if (token === '...') return parseObjRestValue();
  // Parse the key  try ObjAssignable first (broader), fall back to SimpleObjAssignable
  const key = parseObjAssignable();
  // Property: key: value
  if (token === ':') {
    advance();
    let value;
    if (token === 'INDENT') { advance(); value = parseExpression(0); expect('OUTDENT'); }
    else { value = parseExpression(0); }
    return [key, value, ":"];
  }
  // Default: key = value (only valid for SimpleObjAssignable keys)
  if (token === '=') {
    advance();
    let value;
    if (token === 'INDENT') { advance(); value = parseExpression(0); expect('OUTDENT'); }
    else { value = parseExpression(0); }
    return [key, value, "="];
  }
  // Shorthand: {x}
  return [key, key, null];
}

function parseSimpleObjAssignable() {
  if (token === "IDENTIFIER") return parseIdentifier();
  if (token === "PROPERTY") return parseProperty();
  return parseThisProperty();
}

function parseObjAssignable() {
  if (token === "[") {
    const l = loc();
    const _vals_ = [];
    _vals_.push(expect("["));
    _vals_.push(parseExpression());
    _vals_.push(expect("]"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(124, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  if (token === "@") {
    const l = loc();
    const _vals_ = [];
    _vals_.push(expect("@"));
    _vals_.push(expect("["));
    _vals_.push(parseExpression());
    _vals_.push(expect("]"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(125, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  if (token === "IDENTIFIER" || token === "PROPERTY") return parseSimpleObjAssignable();
  return parseAlphaNumeric();
}

function parseObjRestValue() {
  const l = loc();
  if (token === "...") {
    const _vals_ = [];
    _vals_.push(expect("..."));
    if (token === "IDENTIFIER" || token === "PROPERTY" || token === "@") {
      _vals_.push(parseSimpleObjAssignable());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(127, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else if (token === "IDENTIFIER" || token === "PROPERTY" || token === "@" || token === "{" || token === "(" || token === "SUPER" || token === "THIS" || token === "DYNAMIC_IMPORT") {
      _vals_.push(parseObjSpreadExpr());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(128, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in ObjRestValue');
  }
}

function parseObjSpreadExpr() {
  const items = [parseArguments()];
  while (token === "CALL_START") {
    items.push(parseArguments());
  }
  return items;
}

function parseArray() {
  const l = loc();
  if (token === "[") {
    const _vals_ = [];
    _vals_.push(expect("["));
    if (token === "]") {
      _vals_.push(expect("]"));
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(142, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      if (token === ",") {
        _vals_.push(parseElisions());
        _vals_.push(expect("]"));
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(143, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "IDENTIFIER" || token === "@" || token === "[" || token === "{" || token === "NUMBER" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "PARAM_START" || token === "->" || token === "=>" || token === "STRING" || token === "STRING_START" || token === "UNARY" || token === "DO" || token === "UNARY_MATH" || token === "-" || token === "+" || token === "AWAIT" || token === "--" || token === "++" || token === "REACT_ASSIGN" || token === "IF" || token === "UNLESS" || token === "STATEMENT" || token === "TRY" || token === "WHILE" || token === "UNTIL" || token === "LOOP" || token === "FOR" || token === "SWITCH" || token === "CLASS" || token === "COMPONENT" || token === "RENDER" || token === "THROW" || token === "YIELD" || token === "DEF" || token === "ENUM" || token === "RETURN" || token === "IMPORT" || token === "EXPORT" || token === "..." || token === "," || token === "INDENT") {
        _vals_.push(parseArgElisionList());
        _vals_.push(parseOptElisions());
        _vals_.push(expect("]"));
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(144, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Array');
  }
}

function parseArgElisionList() {
  if (token === 'INDENT') {
    advance();
    const inner = parseArgElisionList();
    match(',');
    expect('OUTDENT');
    return inner;
  }
  const result = [parseArgElision()];
  while (true) {
    if (token === ',') {
      advance();
      if (token === "OUTDENT") break;
      if (token === 'TERMINATOR') {
        advance();
        if (token === "OUTDENT") break;
      }
      result.push(parseArgElision());
    } else if (token === 'TERMINATOR') {
      advance();
      if (token === "OUTDENT") break;
      result.push(parseArgElision());
    } else if (token === 'INDENT') {
      advance();
      const inner = parseArgElisionList();
      match(',');
      expect('OUTDENT');
      result.push(...inner);
    } else {
      break;
    }
  }
  return result;
}

function parseArgElision() {
  if (token === ",") {
    const l = loc();
    let _node_ = parseElisions();
    if (token === "IDENTIFIER" || token === "@" || token === "JS" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "[" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "PARAM_START" || token === "->" || token === "=>" || token === "{" || token === "NUMBER" || token === "STRING" || token === "STRING_START" || token === "REGEX" || token === "REGEX_START" || token === "UNARY" || token === "DO" || token === "UNARY_MATH" || token === "-" || token === "+" || token === "AWAIT" || token === "--" || token === "++" || token === "REACT_ASSIGN" || token === "IF" || token === "UNLESS" || token === "STATEMENT" || token === "TRY" || token === "WHILE" || token === "UNTIL" || token === "LOOP" || token === "FOR" || token === "SWITCH" || token === "CLASS" || token === "COMPONENT" || token === "RENDER" || token === "THROW" || token === "YIELD" || token === "DEF" || token === "ENUM" || token === "RETURN" || token === "IMPORT" || token === "EXPORT" || token === "...") {
      const _vals_ = [_node_];
      _vals_.push(parseArg());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(151, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    return _node_;
  }
  return parseArg();
}

function parseOptElisions() {
  if (token === ",") {
    const l = loc();
    const _vals_ = [];
    _vals_.push(expect(","));
    _vals_.push(parseElisions());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(153, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  return parseOptComma();
}

function parseElisions() {
  const items = [parseElision()];
  while (token === ",") {
    items.push(parseElision());
  }
  return items;
}

function parseElision() {
  const items = [parseExpression()];
  while (token === 'TERMINATOR') {
    advance();
    if (token !== EOF && token !== 'OUTDENT') {
      items.push(parseExpression());
    }
  }
  return items;
}

function parseRangeDots() {
  const l = loc();
  if (token === "..") {
    const _vals_ = [];
    _vals_.push(expect(".."));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(158, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else if (token === "...") {
    const _vals_ = [];
    _vals_.push(expect("..."));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(159, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in RangeDots');
  }
}

function parseRange() {
  const l = loc();
  if (token === "[") {
    const _vals_ = [];
    _vals_.push(expect("["));
    _vals_.push(parseExpression());
    _vals_.push(parseRangeDots());
    _vals_.push(parseExpression());
    _vals_.push(expect("]"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(160, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Range');
  }
}

function parseSlice() {
  if (token === ".." || token === "...") {
    const l = loc();
    let _node_ = parseRangeDots();
    if (token === "IDENTIFIER" || token === "@" || token === "[" || token === "{" || token === "NUMBER" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "PARAM_START" || token === "->" || token === "=>" || token === "STRING" || token === "STRING_START" || token === "UNARY" || token === "DO" || token === "UNARY_MATH" || token === "-" || token === "+" || token === "AWAIT" || token === "--" || token === "++" || token === "REACT_ASSIGN" || token === "TRY" || token === "FOR" || token === "SWITCH" || token === "CLASS" || token === "COMPONENT" || token === "RENDER" || token === "THROW" || token === "YIELD" || token === "DEF" || token === "ENUM" || token === "IF" || token === "UNLESS" || token === "RETURN" || token === "STATEMENT" || token === "IMPORT" || token === "EXPORT" || token === "WHILE" || token === "UNTIL" || token === "LOOP") {
      const _vals_ = [_node_];
      _vals_.push(parseExpression());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(163, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    return _node_;
  }
  {
    const l = loc();
    let _node_ = parseRangeDots();
    if (token === "IDENTIFIER" || token === "@" || token === "[" || token === "{" || token === "NUMBER" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "PARAM_START" || token === "->" || token === "=>" || token === "STRING" || token === "STRING_START" || token === "UNARY" || token === "DO" || token === "UNARY_MATH" || token === "-" || token === "+" || token === "AWAIT" || token === "--" || token === "++" || token === "REACT_ASSIGN" || token === "TRY" || token === "FOR" || token === "SWITCH" || token === "CLASS" || token === "COMPONENT" || token === "RENDER" || token === "THROW" || token === "YIELD" || token === "DEF" || token === "ENUM" || token === "IF" || token === "UNLESS" || token === "RETURN" || token === "STATEMENT" || token === "IMPORT" || token === "EXPORT" || token === "WHILE" || token === "UNTIL" || token === "LOOP") {
      const _vals_ = [_node_];
      _vals_.push(parseExpression());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(163, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    return _node_;
  }
}

function parseDef() {
  const l = loc();
  if (token === "DEF") {
    const _vals_ = [];
    _vals_.push(expect("DEF"));
    _vals_.push(parseIdentifier());
    if (token === "CALL_START") {
      _vals_.push(expect("CALL_START"));
      _vals_.push(parseParamList());
      _vals_.push(expect("CALL_END"));
      _vals_.push(parseBlock());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(165, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      _vals_.push(parseBlock());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(166, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Def');
  }
}

function parseCode() {
  const l = loc();
  if (token === "PARAM_START") {
    const _vals_ = [];
    _vals_.push(expect("PARAM_START"));
    _vals_.push(parseParamList());
    _vals_.push(expect("PARAM_END"));
    _vals_.push(parseFuncGlyph());
    _vals_.push(parseBlock());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(167, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    const _vals_ = [];
    _vals_.push(parseFuncGlyph());
    _vals_.push(parseBlock());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(168, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
}

function parseCodeLine() {
  const l = loc();
  if (token === "PARAM_START") {
    const _vals_ = [];
    _vals_.push(expect("PARAM_START"));
    _vals_.push(parseParamList());
    _vals_.push(expect("PARAM_END"));
    _vals_.push(parseFuncGlyph());
    _vals_.push(parseLine());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(169, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    const _vals_ = [];
    _vals_.push(parseFuncGlyph());
    _vals_.push(parseLine());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(170, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
}

function parseFuncGlyph() {
  const l = loc();
  if (token === "->") {
    const _vals_ = [];
    _vals_.push(expect("->"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(171, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else if (token === "=>") {
    const _vals_ = [];
    _vals_.push(expect("=>"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(172, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in FuncGlyph');
  }
}

function parseParamList() {
  if (token === 'INDENT') {
    advance();
    const inner = parseParamList();
    match(',');
    expect('OUTDENT');
    return inner;
  }
  const result = [parseParam()];
  while (true) {
    if (token === ',') {
      advance();
      if (token === "OUTDENT") break;
      if (token === 'TERMINATOR') {
        advance();
        if (token === "OUTDENT") break;
      }
      result.push(parseParam());
    } else if (token === 'TERMINATOR') {
      advance();
      if (token === "OUTDENT") break;
      result.push(parseParam());
    } else if (token === 'INDENT') {
      advance();
      const inner = parseParamList();
      match(',');
      expect('OUTDENT');
      result.push(...inner);
    } else {
      break;
    }
  }
  return result;
}

function parseParam() {
  const l = loc();
  if (token === "...") {
    const _vals_ = [];
    _vals_.push(expect("..."));
    if (token === "IDENTIFIER" || token === "@" || token === "[" || token === "{") {
      _vals_.push(parseParamVar());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(180, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(181, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else {
    const _vals_ = [];
    _vals_.push(parseParamVar());
    if (token === "=") {
      _vals_.push(expect("="));
      _vals_.push(parseExpression());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(179, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(178, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
}

function parseParamVar() {
  if (token === "IDENTIFIER") return parseIdentifier();
  if (token === "@") return parseThisProperty();
  if (token === "[") return parseArray();
  return parseObject();
}

function parseSplat() {
  const l = loc();
  if (token === "...") {
    const _vals_ = [];
    _vals_.push(expect("..."));
    _vals_.push(parseExpression());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(186, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Splat');
  }
}

function parseInvocation() {
  const l = loc();
  if (token === "SUPER") {
    const _vals_ = [];
    _vals_.push(expect("SUPER"));
    _vals_.push(parseArguments());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(190, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else if (token === "DYNAMIC_IMPORT") {
    const _vals_ = [];
    _vals_.push(expect("DYNAMIC_IMPORT"));
    _vals_.push(parseArguments());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(191, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    const _vals_ = [];
    _vals_.push(parseValue());
    if (token === "ES6_OPTIONAL_CALL") {
      _vals_.push(expect("ES6_OPTIONAL_CALL"));
      _vals_.push(parseArguments());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(189, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      if (token === "CALL_START") {
        _vals_.push(parseArguments());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(188, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "STRING" || token === "STRING_START") {
        _vals_.push(parseString());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(187, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
    }
  }
}

function parseArguments() {
  const l = loc();
  if (token === "CALL_START") {
    const _vals_ = [];
    _vals_.push(expect("CALL_START"));
    if (token === "CALL_END") {
      _vals_.push(expect("CALL_END"));
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(192, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      _vals_.push(parseArgList());
      _vals_.push(parseOptComma());
      _vals_.push(expect("CALL_END"));
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(193, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Arguments');
  }
}

function parseArgList() {
  if (token === 'INDENT') {
    advance();
    const inner = parseArgList();
    match(',');
    expect('OUTDENT');
    return inner;
  }
  const result = [parseArg()];
  while (true) {
    if (token === ',') {
      advance();
      if (token === "OUTDENT") break;
      if (token === 'TERMINATOR') {
        advance();
        if (token === "OUTDENT") break;
      }
      result.push(parseArg());
    } else if (token === 'TERMINATOR') {
      advance();
      if (token === "OUTDENT") break;
      result.push(parseArg());
    } else if (token === 'INDENT') {
      advance();
      const inner = parseArgList();
      match(',');
      expect('OUTDENT');
      result.push(...inner);
    } else {
      break;
    }
  }
  return result;
}

function parseArg() {
  if (token === "...") {
    const _spec = speculate(() => parseSplat());
    if (_spec !== null) return _spec;
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(202, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  return parseExpression();
}

function parseSimpleArgs() {
  const result = [parseExpression()];
  while (token === ',') {
    advance();
    result.push(parseExpression());
  }
  return result;
}

function parseThis() {
  const l = loc();
  if (token === "THIS") {
    const _vals_ = [];
    _vals_.push(expect("THIS"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(205, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else if (token === "@") {
    const _vals_ = [];
    _vals_.push(expect("@"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(206, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in This');
  }
}

function parseThisProperty() {
  const l = loc();
  if (token === "@") {
    const _vals_ = [];
    _vals_.push(expect("@"));
    _vals_.push(parseProperty());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(207, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in ThisProperty');
  }
}

function parseSuper() {
  const l = loc();
  if (token === "SUPER") {
    const _vals_ = [];
    _vals_.push(expect("SUPER"));
    if (token === "INDEX_START") {
      _vals_.push(expect("INDEX_START"));
      if (token === "INDENT") {
        _vals_.push(expect("INDENT"));
        _vals_.push(parseExpression());
        _vals_.push(expect("OUTDENT"));
        _vals_.push(expect("INDEX_END"));
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(210, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "IDENTIFIER" || token === "@" || token === "[" || token === "{" || token === "NUMBER" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "PARAM_START" || token === "->" || token === "=>" || token === "STRING" || token === "STRING_START" || token === "UNARY" || token === "DO" || token === "UNARY_MATH" || token === "-" || token === "+" || token === "AWAIT" || token === "--" || token === "++" || token === "REACT_ASSIGN" || token === "TRY" || token === "FOR" || token === "SWITCH" || token === "CLASS" || token === "COMPONENT" || token === "RENDER" || token === "THROW" || token === "YIELD" || token === "DEF" || token === "ENUM" || token === "IF" || token === "UNLESS" || token === "RETURN" || token === "STATEMENT" || token === "IMPORT" || token === "EXPORT" || token === "WHILE" || token === "UNTIL" || token === "LOOP") {
        _vals_.push(parseExpression());
        _vals_.push(expect("INDEX_END"));
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(209, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
    }
    else if (token === ".") {
      _vals_.push(expect("."));
      _vals_.push(parseProperty());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(208, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Super');
  }
}

function parseMetaProperty() {
  const l = loc();
  if (token === "NEW_TARGET") {
    const _vals_ = [];
    _vals_.push(expect("NEW_TARGET"));
    _vals_.push(expect("."));
    _vals_.push(parseProperty());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(211, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else if (token === "IMPORT_META") {
    const _vals_ = [];
    _vals_.push(expect("IMPORT_META"));
    _vals_.push(expect("."));
    _vals_.push(parseProperty());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(212, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in MetaProperty');
  }
}

function parseBlock() {
  const l = loc();
  if (token === "INDENT") {
    const _vals_ = [];
    _vals_.push(expect("INDENT"));
    if (token === "OUTDENT") {
      _vals_.push(expect("OUTDENT"));
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(213, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      _vals_.push(parseBody());
      _vals_.push(expect("OUTDENT"));
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(214, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Block');
  }
}

function parseParenthetical() {
  const l = loc();
  if (token === "(") {
    const _vals_ = [];
    _vals_.push(expect("("));
    if (token === "INDENT") {
      _vals_.push(expect("INDENT"));
      _vals_.push(parseBody());
      _vals_.push(expect("OUTDENT"));
      _vals_.push(expect(")"));
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(216, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      _vals_.push(parseBody());
      _vals_.push(expect(")"));
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(215, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Parenthetical');
  }
}

function parseOptComma() {
  const l = loc();
  if (token === ",") {
    const _vals_ = [];
    _vals_.push(expect(","));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(218, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    { const $ = [], $0 = -1; const _r = ruleActions(217, [], [], {}); return _r != null ? withLoc(_r, l) : withLoc([], l); }
  }
}

function parseReturn() {
  const l = loc();
  if (token === "RETURN") {
    const _vals_ = [];
    _vals_.push(expect("RETURN"));
    if (token === "INDENT") {
      _vals_.push(expect("INDENT"));
      _vals_.push(parseObject());
      _vals_.push(expect("OUTDENT"));
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(220, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      if (token === "IDENTIFIER" || token === "@" || token === "[" || token === "{" || token === "NUMBER" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "PARAM_START" || token === "->" || token === "=>" || token === "STRING" || token === "STRING_START" || token === "UNARY" || token === "DO" || token === "UNARY_MATH" || token === "-" || token === "+" || token === "AWAIT" || token === "--" || token === "++" || token === "REACT_ASSIGN" || token === "TRY" || token === "FOR" || token === "SWITCH" || token === "CLASS" || token === "COMPONENT" || token === "RENDER" || token === "THROW" || token === "YIELD" || token === "DEF" || token === "ENUM" || token === "IF" || token === "UNLESS" || token === "RETURN" || token === "STATEMENT" || token === "IMPORT" || token === "EXPORT" || token === "WHILE" || token === "UNTIL" || token === "LOOP") {
        _vals_.push(parseExpression());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(219, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else {
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(221, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Return');
  }
}

function parseThrow() {
  const l = loc();
  if (token === "THROW") {
    const _vals_ = [];
    _vals_.push(expect("THROW"));
    if (token === "INDENT") {
      _vals_.push(expect("INDENT"));
      _vals_.push(parseObject());
      _vals_.push(expect("OUTDENT"));
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(223, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      _vals_.push(parseExpression());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(222, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Throw');
  }
}

function parseYield() {
  const l = loc();
  if (token === "YIELD") {
    const _vals_ = [];
    _vals_.push(expect("YIELD"));
    if (token === "INDENT") {
      _vals_.push(expect("INDENT"));
      _vals_.push(parseObject());
      _vals_.push(expect("OUTDENT"));
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(226, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else if (token === "FROM") {
      _vals_.push(expect("FROM"));
      _vals_.push(parseExpression());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(227, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      if (token === "IDENTIFIER" || token === "@" || token === "[" || token === "{" || token === "NUMBER" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "PARAM_START" || token === "->" || token === "=>" || token === "STRING" || token === "STRING_START" || token === "UNARY" || token === "DO" || token === "UNARY_MATH" || token === "-" || token === "+" || token === "AWAIT" || token === "--" || token === "++" || token === "REACT_ASSIGN" || token === "TRY" || token === "FOR" || token === "SWITCH" || token === "CLASS" || token === "COMPONENT" || token === "RENDER" || token === "THROW" || token === "YIELD" || token === "DEF" || token === "ENUM" || token === "IF" || token === "UNLESS" || token === "RETURN" || token === "STATEMENT" || token === "IMPORT" || token === "EXPORT" || token === "WHILE" || token === "UNTIL" || token === "LOOP") {
        _vals_.push(parseExpression());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(225, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else {
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(224, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Yield');
  }
}

function parseIfBlock() {
  const l = loc();
  // Base case
  const _vals_ = [];
  _vals_.push(expect("IF"));
  _vals_.push(parseExpression());
  _vals_.push(parseBlock());
  let _node_ = (function() { { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(228, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); } }).call({});
  // Recursive continuation  loop
  while (token === "ELSE") {
    const _saved_ = mark();
    advance(); // consume ELSE
    if (token !== "IF") { reset(_saved_); break; }
    const _rvals_ = [_node_];
    _rvals_.push("ELSE"); // already consumed
    _rvals_.push(expect("IF"));
    _rvals_.push(parseExpression());
    _rvals_.push(parseBlock());
    const $ = _rvals_, $0 = _rvals_.length - 1;
    const _r = ruleActions(229, _rvals_, [], {});
    _node_ = _r != null ? withLoc(_r, l) : _node_;
  }
  return _node_;
}

function parseUnlessBlock() {
  const l = loc();
  if (token === "UNLESS") {
    const _vals_ = [];
    _vals_.push(expect("UNLESS"));
    _vals_.push(parseExpression());
    _vals_.push(parseBlock());
    if (token === "ELSE") {
      _vals_.push(expect("ELSE"));
      _vals_.push(parseBlock());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(231, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(230, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in UnlessBlock');
  }
}

function parseIf() {
  if (token === "IF") {
    const l = loc();
    let _node_ = parseIfBlock();
    if (token === "ELSE") {
      const _vals_ = [_node_];
      _vals_.push(expect("ELSE"));
      _vals_.push(parseBlock());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(233, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    return _node_;
  }
  return parseUnlessBlock();
}

function parseTry() {
  const l = loc();
  if (token === "TRY") {
    const _vals_ = [];
    _vals_.push(expect("TRY"));
    _vals_.push(parseBlock());
    if (token === "CATCH") _vals_.push(parseCatch()); // optional
    if (token === "FINALLY") _vals_.push(expect("FINALLY")); // optional
    if (token === "INDENT") _vals_.push(parseBlock()); // optional
    const _rid_ = ({5:243,4:242,3:241,2:240})[_vals_.length];
    if (_rid_ !== undefined) {
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(_rid_, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : withLoc($[$0], l);
    }
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(243, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Try');
  }
}

function parseCatch() {
  const l = loc();
  if (token === "CATCH") {
    const _vals_ = [];
    _vals_.push(expect("CATCH"));
    if (token === "IDENTIFIER") {
      _vals_.push(parseIdentifier());
      _vals_.push(parseBlock());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(244, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else if (token === "{") {
      _vals_.push(parseObject());
      _vals_.push(parseBlock());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(245, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else if (token === "INDENT") {
      _vals_.push(parseBlock());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(246, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Catch');
  }
}

function parseSwitch() {
  const l = loc();
  if (token === "SWITCH") {
    const _vals_ = [];
    _vals_.push(expect("SWITCH"));
    if (token === "INDENT") {
      _vals_.push(expect("INDENT"));
      _vals_.push(parseWhens());
      if (token === "ELSE") {
        _vals_.push(expect("ELSE"));
        _vals_.push(parseBlock());
        _vals_.push(expect("OUTDENT"));
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(250, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "OUTDENT") {
        _vals_.push(expect("OUTDENT"));
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(249, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
    }
    else {
      _vals_.push(parseExpression());
      _vals_.push(expect("INDENT"));
      _vals_.push(parseWhens());
      if (token === "ELSE") {
        _vals_.push(expect("ELSE"));
        _vals_.push(parseBlock());
        _vals_.push(expect("OUTDENT"));
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(248, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "OUTDENT") {
        _vals_.push(expect("OUTDENT"));
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(247, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Switch');
  }
}

function parseWhens() {
  const items = [parseWhen()];
  while (token === "LEADING_WHEN") {
    items.push(parseWhen());
  }
  return items;
}

function parseWhen() {
  const l = loc();
  if (token === "LEADING_WHEN") {
    const _vals_ = [];
    _vals_.push(expect("LEADING_WHEN"));
    _vals_.push(parseSimpleArgs());
    _vals_.push(parseBlock());
    if (token === "TERMINATOR") {
      _vals_.push(expect("TERMINATOR"));
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(254, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(253, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in When');
  }
}

function parseWhileSource() {
  const l = loc();
  if (token === "WHILE") {
    const _vals_ = [];
    _vals_.push(expect("WHILE"));
    _vals_.push(parseExpression());
    if (token === "WHEN") {
      _vals_.push(expect("WHEN"));
      _vals_.push(parseExpression());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(256, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(255, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else if (token === "UNTIL") {
    const _vals_ = [];
    _vals_.push(expect("UNTIL"));
    _vals_.push(parseExpression());
    if (token === "WHEN") {
      _vals_.push(expect("WHEN"));
      _vals_.push(parseExpression());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(258, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(257, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in WhileSource');
  }
}

function parseWhile() {
  if (token === "LOOP") return parseLoop();
  {
    const l = loc();
    let _node_ = parseWhileSource();
    if (token === "INDENT") {
      const _vals_ = [_node_];
      _vals_.push(parseBlock());
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(259, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : _node_;
    }
    return _node_;
  }
}

function parseLoop() {
  const l = loc();
  if (token === "LOOP") {
    const _vals_ = [];
    _vals_.push(expect("LOOP"));
    if (token === "INDENT") {
      _vals_.push(parseBlock());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(263, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else if (token === "IDENTIFIER" || token === "@" || token === "[" || token === "{" || token === "NUMBER" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "PARAM_START" || token === "->" || token === "=>" || token === "STRING" || token === "STRING_START" || token === "UNARY" || token === "DO" || token === "UNARY_MATH" || token === "-" || token === "+" || token === "AWAIT" || token === "--" || token === "++" || token === "REACT_ASSIGN" || token === "TRY" || token === "FOR" || token === "SWITCH" || token === "CLASS" || token === "COMPONENT" || token === "RENDER" || token === "THROW" || token === "YIELD" || token === "DEF" || token === "ENUM" || token === "IF" || token === "UNLESS" || token === "RETURN" || token === "STATEMENT" || token === "IMPORT" || token === "EXPORT" || token === "WHILE" || token === "UNTIL" || token === "LOOP") {
      _vals_.push(parseExpression());
      if (token === "INDENT") {
        _vals_.push(parseBlock());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(265, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else {
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(264, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Loop');
  }
}

function parseFor() {
  const l = loc();
  expect('FOR');
  // Check for range: FOR Range Block (use speculation  [a,b] could be destructuring)
  if (token === '[') {
    const range = speculate(() => parseRange());
    if (range !== null) {
      if (token === 'BY') {
        advance();
        const step = parseExpression(0);
        const block = parseBlock();
        return withLoc(["for-in", [], range, step, null, block], l);
      }
      const block = parseBlock();
      return withLoc(["for-in", [], range, null, null, block], l);
    }
  }
  // Check for AWAIT (async for-as)
  if (token === 'AWAIT') {
    advance();
    const vars = parseForVariables();
    expect('FORAS');
    const iter = parseExpression(0);
    let guard = null;
    if (token === 'WHEN') { advance(); guard = parseExpression(0); }
    const block = parseBlock();
    return withLoc(["for-as", vars, iter, true, guard, block], l);
  }
  // Check for OWN (for own k of obj)
  if (token === 'OWN') {
    advance();
    const vars = parseForVariables();
    expect('FOROF');
    const obj = parseExpression(0);
    let guard = null;
    if (token === 'WHEN') { advance(); guard = parseExpression(0); }
    const block = parseBlock();
    return withLoc(["for-of", vars, obj, true, guard, block], l);
  }
  // Regular for: parse variables, then dispatch on FORIN/FOROF/FORAS
  const vars = parseForVariables();
  if (token === 'FORIN') {
    advance();
    const arr = parseExpression(0);
    let step = null, guard = null;
    if (token === 'WHEN') { advance(); guard = parseExpression(0); }
    if (token === 'BY') { advance(); step = parseExpression(0); }
    if (!guard && token === 'WHEN') { advance(); guard = parseExpression(0); }
    const block = parseBlock();
    return withLoc(["for-in", vars, arr, step, guard, block], l);
  }
  if (token === 'FOROF') {
    advance();
    const obj = parseExpression(0);
    let guard = null;
    if (token === 'WHEN') { advance(); guard = parseExpression(0); }
    const block = parseBlock();
    return withLoc(["for-of", vars, obj, false, guard, block], l);
  }
  if (token === 'FORAS' || token === 'FORASAWAIT') {
    const isAsync = token === 'FORASAWAIT';
    advance();
    const iter = parseExpression(0);
    let guard = null;
    if (token === 'WHEN') { advance(); guard = parseExpression(0); }
    const block = parseBlock();
    return withLoc(["for-as", vars, iter, isAsync, guard, block], l);
  }
  throw new Error('Parse error in For: expected FORIN/FOROF/FORAS after variables, got ' + token);
}

function parseForValue() {
  const l = loc();
  const _vals_ = [];
  _vals_.push(parseParamVar());
  if (token === "=") {
    _vals_.push(expect("="));
    _vals_.push(parseExpression());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(301, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(300, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
}

function parseForVariables() {
  const l = loc();
  const _vals_ = [];
  _vals_.push(parseForValue());
  if (token === ",") {
    _vals_.push(expect(","));
    _vals_.push(parseForValue());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(303, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(302, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
}

function parseClass() {
  const l = loc();
  if (token === "CLASS") {
    const _vals_ = [];
    _vals_.push(expect("CLASS"));
    if (token === "IDENTIFIER" || token === "@" || token === "[" || token === "{" || token === "NUMBER" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "PARAM_START" || token === "->" || token === "=>" || token === "STRING" || token === "STRING_START") _vals_.push(parseSimpleAssignable()); // optional
    if (token === "EXTENDS") _vals_.push(expect("EXTENDS")); // optional
    if (token === "IDENTIFIER" || token === "@" || token === "[" || token === "{" || token === "NUMBER" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "PARAM_START" || token === "->" || token === "=>" || token === "STRING" || token === "STRING_START" || token === "UNARY" || token === "DO" || token === "UNARY_MATH" || token === "-" || token === "+" || token === "AWAIT" || token === "--" || token === "++" || token === "REACT_ASSIGN" || token === "TRY" || token === "FOR" || token === "SWITCH" || token === "CLASS" || token === "COMPONENT" || token === "RENDER" || token === "THROW" || token === "YIELD" || token === "DEF" || token === "ENUM" || token === "IF" || token === "UNLESS" || token === "RETURN" || token === "STATEMENT" || token === "IMPORT" || token === "EXPORT" || token === "WHILE" || token === "UNTIL" || token === "LOOP") _vals_.push(parseExpression()); // optional
    if (token === "INDENT") _vals_.push(parseBlock()); // optional
    const _rid_ = ({5:311,4:307,4:310,3:306,3:309,2:305,2:308,1:304})[_vals_.length];
    if (_rid_ !== undefined) {
      const $ = _vals_, $0 = _vals_.length - 1;
      const _r = ruleActions(_rid_, _vals_, [], {});
      return _r != null ? withLoc(_r, l) : withLoc($[$0], l);
    }
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(311, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Class');
  }
}

function parseEnum() {
  const l = loc();
  if (token === "ENUM") {
    const _vals_ = [];
    _vals_.push(expect("ENUM"));
    _vals_.push(parseIdentifier());
    _vals_.push(parseBlock());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(312, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Enum');
  }
}

function parseComponent() {
  const l = loc();
  if (token === "COMPONENT") {
    const _vals_ = [];
    _vals_.push(expect("COMPONENT"));
    _vals_.push(expect("INDENT"));
    _vals_.push(parseComponentBody());
    _vals_.push(expect("OUTDENT"));
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(313, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Component');
  }
}

function parseComponentBody() {
  const items = [parseComponentLine()];
  while (token === 'TERMINATOR') {
    advance();
    if (token !== EOF && token !== 'OUTDENT') {
      items.push(parseComponentLine());
    }
  }
  return items;
}

function parseComponentLine() {
  if (token === "IMPORT" || token === "EXPORT") return parseStatement();
  return parseExpression();
}

function parseRender() {
  const l = loc();
  if (token === "RENDER") {
    const _vals_ = [];
    _vals_.push(expect("RENDER"));
    _vals_.push(parseBlock());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(320, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Render');
  }
}

function parseImport() {
  const l = loc();
  if (token === "IMPORT") {
    const _vals_ = [];
    _vals_.push(expect("IMPORT"));
    if (token === "{") {
      _vals_.push(expect("{"));
      if (token === "IDENTIFIER" || token === "DEFAULT" || token === "INDENT") {
        _vals_.push(parseImportSpecifierList());
        _vals_.push(parseOptComma());
        _vals_.push(expect("}"));
        _vals_.push(expect("FROM"));
        _vals_.push(parseString());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(325, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "}") {
        _vals_.push(expect("}"));
        _vals_.push(expect("FROM"));
        _vals_.push(parseString());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(324, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
    }
    else {
      if (token === "IDENTIFIER") {
        _vals_.push(parseImportDefaultSpecifier());
        if (token === ",") {
          _vals_.push(expect(","));
          _vals_.push(expect("{"));
          _vals_.push(parseImportSpecifierList());
          _vals_.push(parseOptComma());
          _vals_.push(expect("}"));
          _vals_.push(expect("FROM"));
          _vals_.push(parseString());
          { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(327, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
        }
        else if (token === ",") {
          _vals_.push(expect(","));
          _vals_.push(parseImportNamespaceSpecifier());
          _vals_.push(expect("FROM"));
          _vals_.push(parseString());
          { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(326, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
        }
        else if (token === "FROM") {
          _vals_.push(expect("FROM"));
          _vals_.push(parseString());
          { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(322, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
        }
      }
      else if (token === "IMPORT_ALL") {
        _vals_.push(parseImportNamespaceSpecifier());
        _vals_.push(expect("FROM"));
        _vals_.push(parseString());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(323, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "STRING" || token === "STRING_START") {
        _vals_.push(parseString());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(321, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Import');
  }
}

function parseImportSpecifierList() {
  if (token === 'INDENT') {
    advance();
    const inner = parseImportSpecifierList();
    match(',');
    expect('OUTDENT');
    return inner;
  }
  const result = [parseImportSpecifier()];
  while (true) {
    if (token === ',') {
      advance();
      if (token === "OUTDENT") break;
      if (token === 'TERMINATOR') {
        advance();
        if (token === "OUTDENT") break;
      }
      result.push(parseImportSpecifier());
    } else if (token === 'TERMINATOR') {
      advance();
      if (token === "OUTDENT") break;
      result.push(parseImportSpecifier());
    } else if (token === 'INDENT') {
      advance();
      const inner = parseImportSpecifierList();
      match(',');
      expect('OUTDENT');
      result.push(...inner);
    } else {
      break;
    }
  }
  return result;
}

function parseImportSpecifier() {
  const l = loc();
  if (token === "DEFAULT") {
    const _vals_ = [];
    _vals_.push(expect("DEFAULT"));
    if (token === "AS") {
      _vals_.push(expect("AS"));
      _vals_.push(parseIdentifier());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(336, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(335, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else {
    const _vals_ = [];
    _vals_.push(parseIdentifier());
    if (token === "AS") {
      _vals_.push(expect("AS"));
      _vals_.push(parseIdentifier());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(334, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(333, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
}

function parseImportDefaultSpecifier() {
  return parseIdentifier();
}

function parseImportNamespaceSpecifier() {
  const l = loc();
  if (token === "IMPORT_ALL") {
    const _vals_ = [];
    _vals_.push(expect("IMPORT_ALL"));
    _vals_.push(expect("AS"));
    _vals_.push(parseIdentifier());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(338, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in ImportNamespaceSpecifier');
  }
}

function parseExport() {
  const l = loc();
  if (token === "EXPORT") {
    const _vals_ = [];
    _vals_.push(expect("EXPORT"));
    if (token === "{") {
      _vals_.push(expect("{"));
      if (token === "IDENTIFIER" || token === "DEFAULT" || token === "INDENT") {
        _vals_.push(parseExportSpecifierList());
        _vals_.push(parseOptComma());
        _vals_.push(expect("}"));
        _vals_.push(expect("FROM"));
        _vals_.push(parseString());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(356, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "IDENTIFIER" || token === "DEFAULT" || token === "INDENT") {
        _vals_.push(parseExportSpecifierList());
        _vals_.push(parseOptComma());
        _vals_.push(expect("}"));
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(340, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "}") {
        _vals_.push(expect("}"));
        _vals_.push(expect("FROM"));
        _vals_.push(parseString());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(355, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "}") {
        _vals_.push(expect("}"));
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(339, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
    }
    else if (token === "DEFAULT") {
      _vals_.push(expect("DEFAULT"));
      if (token === "INDENT") {
        _vals_.push(expect("INDENT"));
        _vals_.push(parseObject());
        _vals_.push(expect("OUTDENT"));
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(353, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "IDENTIFIER" || token === "@" || token === "[" || token === "{" || token === "NUMBER" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "PARAM_START" || token === "->" || token === "=>" || token === "STRING" || token === "STRING_START" || token === "UNARY" || token === "DO" || token === "UNARY_MATH" || token === "-" || token === "+" || token === "AWAIT" || token === "--" || token === "++" || token === "REACT_ASSIGN" || token === "TRY" || token === "FOR" || token === "SWITCH" || token === "CLASS" || token === "COMPONENT" || token === "RENDER" || token === "THROW" || token === "YIELD" || token === "DEF" || token === "ENUM" || token === "IF" || token === "UNLESS" || token === "RETURN" || token === "STATEMENT" || token === "IMPORT" || token === "EXPORT" || token === "WHILE" || token === "UNTIL" || token === "LOOP") {
        _vals_.push(parseExpression());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(352, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
    }
    else if (token === "EXPORT_ALL") {
      _vals_.push(expect("EXPORT_ALL"));
      _vals_.push(expect("FROM"));
      _vals_.push(parseString());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(354, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      if (token === "IDENTIFIER") {
        _vals_.push(parseIdentifier());
        _vals_.push(expect("="));
        if (token === "INDENT") {
          _vals_.push(expect("INDENT"));
          _vals_.push(parseExpression());
          _vals_.push(expect("OUTDENT"));
          { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(347, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
        }
        else if (token === "TERMINATOR") {
          _vals_.push(expect("TERMINATOR"));
          _vals_.push(parseExpression());
          { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(346, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
        }
        else if (token === "IDENTIFIER" || token === "@" || token === "[" || token === "{" || token === "NUMBER" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "PARAM_START" || token === "->" || token === "=>" || token === "STRING" || token === "STRING_START" || token === "UNARY" || token === "DO" || token === "UNARY_MATH" || token === "-" || token === "+" || token === "AWAIT" || token === "--" || token === "++" || token === "REACT_ASSIGN" || token === "TRY" || token === "FOR" || token === "SWITCH" || token === "CLASS" || token === "COMPONENT" || token === "RENDER" || token === "THROW" || token === "YIELD" || token === "DEF" || token === "ENUM" || token === "IF" || token === "UNLESS" || token === "RETURN" || token === "STATEMENT" || token === "IMPORT" || token === "EXPORT" || token === "WHILE" || token === "UNTIL" || token === "LOOP") {
          _vals_.push(parseExpression());
          { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(345, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
        }
      }
      else if (token === "CLASS") {
        _vals_.push(parseClass());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(341, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "COMPONENT") {
        _vals_.push(parseComponent());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(342, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "DEF") {
        _vals_.push(parseDef());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(343, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "ENUM") {
        _vals_.push(parseEnum());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(344, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "IDENTIFIER" || token === "@" || token === "PARAM_START" || token === "[" || token === "{" || token === "NUMBER" || token === "STRING" || token === "STRING_START" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "->" || token === "=>") {
        _vals_.push(parseReactiveAssign());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(348, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "IDENTIFIER" || token === "@" || token === "PARAM_START" || token === "[" || token === "{" || token === "NUMBER" || token === "STRING" || token === "STRING_START" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "->" || token === "=>") {
        _vals_.push(parseComputedAssign());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(349, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "IDENTIFIER" || token === "@" || token === "PARAM_START" || token === "[" || token === "{" || token === "NUMBER" || token === "STRING" || token === "STRING_START" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "->" || token === "=>") {
        _vals_.push(parseReadonlyAssign());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(350, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "IDENTIFIER" || token === "@" || token === "PARAM_START" || token === "[" || token === "{" || token === "NUMBER" || token === "STRING" || token === "STRING_START" || token === "JS" || token === "REGEX" || token === "REGEX_START" || token === "UNDEFINED" || token === "NULL" || token === "BOOL" || token === "INFINITY" || token === "NAN" || token === "(" || token === "SUPER" || token === "DYNAMIC_IMPORT" || token === "DO_IIFE" || token === "THIS" || token === "NEW_TARGET" || token === "IMPORT_META" || token === "->" || token === "=>" || token === "REACT_ASSIGN") {
        _vals_.push(parseReactAssign());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(351, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
    }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in Export');
  }
}

function parseExportSpecifierList() {
  if (token === 'INDENT') {
    advance();
    const inner = parseExportSpecifierList();
    match(',');
    expect('OUTDENT');
    return inner;
  }
  const result = [parseExportSpecifier()];
  while (true) {
    if (token === ',') {
      advance();
      if (token === "OUTDENT") break;
      if (token === 'TERMINATOR') {
        advance();
        if (token === "OUTDENT") break;
      }
      result.push(parseExportSpecifier());
    } else if (token === 'TERMINATOR') {
      advance();
      if (token === "OUTDENT") break;
      result.push(parseExportSpecifier());
    } else if (token === 'INDENT') {
      advance();
      const inner = parseExportSpecifierList();
      match(',');
      expect('OUTDENT');
      result.push(...inner);
    } else {
      break;
    }
  }
  return result;
}

function parseExportSpecifier() {
  const l = loc();
  if (token === "DEFAULT") {
    const _vals_ = [];
    _vals_.push(expect("DEFAULT"));
    if (token === "AS") {
      _vals_.push(expect("AS"));
      _vals_.push(parseIdentifier());
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(366, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
    else {
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(365, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
  else {
    const _vals_ = [];
    _vals_.push(parseIdentifier());
    if (token === "AS") {
      _vals_.push(expect("AS"));
      if (token === "IDENTIFIER") {
        _vals_.push(parseIdentifier());
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(363, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
      else if (token === "DEFAULT") {
        _vals_.push(expect("DEFAULT"));
        { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(364, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
      }
    }
    else {
      { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(362, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
    }
  }
}

function parseOperationLine() {
  const l = loc();
  if (token === "UNARY") {
    const _vals_ = [];
    _vals_.push(expect("UNARY"));
    _vals_.push(parseExpressionLine());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(367, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else if (token === "DO") {
    const _vals_ = [];
    _vals_.push(expect("DO"));
    _vals_.push(parseExpressionLine());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(368, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else if (token === "DO_IIFE") {
    const _vals_ = [];
    _vals_.push(expect("DO_IIFE"));
    _vals_.push(parseCodeLine());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(369, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in OperationLine');
  }
}

function parseOperation() {
  return parseExpression(0);
}

function parseDoIife() {
  const l = loc();
  if (token === "DO_IIFE") {
    const _vals_ = [];
    _vals_.push(expect("DO_IIFE"));
    _vals_.push(parseCode());
    { const $ = _vals_, $0 = _vals_.length - 1; const _r = ruleActions(407, _vals_, [], {}); return _r != null ? withLoc(_r, l) : withLoc($[$0], l); }
  }
  else {
    throw new Error('Parse error: unexpected token ' + token + ' in DoIife');
  }
}

const parserInstance = {
  parse(input) {
    lexerAdapter = Object.create(this.lexer);
    const sharedState = { ctx: {} };
    for (const k in this.ctx) sharedState.ctx[k] = this.ctx[k];
    lexerAdapter.setInput(input, sharedState.ctx);
    sharedState.ctx.lexer = lexerAdapter;
    sharedState.ctx.parser = this;
    if (!lexerAdapter.loc) lexerAdapter.loc = {};
    advance();
    return parseRoot();
  },
  lexer: null,
  ctx: {},
};

const createParser = (init = {}) => {
  const p = Object.create(parserInstance);
  Object.defineProperty(p, "ctx", {
    value: { ...init },
    enumerable: false,
    writable: true,
    configurable: true,
  });
  return p;
};

const parser = /*#__PURE__*/createParser();

export { parser };
export const Parser = createParser;
export const parse = parser.parse.bind(parser);
export default parser;