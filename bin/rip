#!/usr/bin/env bun

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { execSync, spawn } from 'child_process';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { Compiler } from '../src/compiler.js';
import { startREPL } from '../src/repl.js';
import packageJson from '../package.json' with { type: 'json' };

// Get the directory where this script lives
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const VERSION = packageJson.version;
const SUMMARY = packageJson.description;

function printHelp() {
  console.log(`
Rip ${VERSION} - ${SUMMARY}

Usage:
  rip [options] [file]
  rip                           # Start interactive REPL (no arguments)

Options:
  -c, --compile       Show compiled JavaScript output
  -h, --help          Show this help message
  -o, --output <file> Write JavaScript to file
  -q, --quiet         Suppress headers
  -r, --repl          Start interactive REPL
  -s, --sexpr         Show s-expressions (only, unless -c also specified)
  -t, --tokens        Show token stream (only, unless -c also specified)
  -v, --version       Show version number
  -w, --web           Launch browser REPL (auto-opens + auto-shutdown)

Examples:
  rip                           # Interactive REPL (terminal)
  rip script.rip                # Execute script directly
  rip script.rip arg1 arg2      # Execute with arguments
  rip -c example.rip            # Compile and show JavaScript
  rip -o output.js example.rip  # Compile and save to file
  rip -s example.rip            # Show ONLY s-expressions
  rip -t example.rip            # Show ONLY tokens
  rip -s -c example.rip         # Show s-expressions AND JavaScript
  rip -s -t -c example.rip      # Show everything (full debug mode)
  rip -q -c example.rip         # Just the JS, no headers (for piping)
  rip -w                        # Launch browser REPL (auto-opens)
  echo 'x = 1 + 2' | rip -c     # Compile from stdin

Shebang support:
  #!/usr/bin/env rip            # Execute with rip
  #!/usr/bin/env bun            # Execute with bun (also works)
`);
}

async function main() {
  const args = process.argv.slice(2);

  if (args.includes('-h') || args.includes('--help')) {
    printHelp();
    process.exit(0);
  }

  if (args.includes('-v') || args.includes('--version')) {
    console.log(`Rip ${VERSION} - ${SUMMARY}`);
    process.exit(0);
  }

  // Launch local browser REPL (starts server + opens browser)
  if (args.includes('-w') || args.includes('--web')) {
    console.log('ðŸš€ Starting Rip browser REPL...\n');

    // Start the server and capture output to get the actual port
    const servePath = join(__dirname, '../scripts/serve.js');
    const serverProcess = spawn('bun', [servePath], {
      stdio: ['inherit', 'pipe', 'inherit'],
      detached: false
    });

    let actualPort = null;

    // Capture server output and extract port
    serverProcess.stdout.on('data', (data) => {
      const output = data.toString();
      process.stdout.write(output);

      // Parse port from "Server running at http://localhost:PORT"
      if (!actualPort) {
        const match = output.match(/localhost:(\d+)/);
        if (match) {
          actualPort = match[1];

          // Open browser once we know the port
          setTimeout(() => {
            const openCmd = process.platform === 'darwin' ? 'open' :
                            process.platform === 'win32' ? 'start' : 'xdg-open';
            execSync(`${openCmd} http://localhost:${actualPort}/`);
            console.log('\nðŸ“± Press Ctrl+C to stop server\n');
          }, 300);
        }
      }
    });

    // Keep server running (don't exit)
    return;
  }

  // Check if REPL should be started
  // Launch REPL if: no args AND stdin is a TTY (not piped), OR explicit -r flag
  const isTTY = process.stdin.isTTY;
  if ((args.length === 0 && isTTY) || args.includes('-r') || args.includes('--repl')) {
    startREPL();
    return;
  }

  const showTokens = args.includes('-t') || args.includes('--tokens');
  const showSExpr = args.includes('-s') || args.includes('--sexpr');
  const showCompiled = args.includes('-c') || args.includes('--compile');
  const quiet = args.includes('-q') || args.includes('--quiet');

  const options = {
    showTokens,
    showSExpr,
    quiet
  };

  // Find input file (last non-option argument)
  let inputFile = null;
  let outputFile = null;

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '-o' || args[i] === '--output') {
      outputFile = args[i + 1];
      i++;
    } else if (!args[i].startsWith('-') && !inputFile) {
      inputFile = args[i];  // Only take first non-option as input file
    }
  }

  // If .rip file without compile flags â†’ execute instead of compile
  const hasCompileFlag = showCompiled || showTokens || showSExpr || outputFile;
  if (inputFile && inputFile.endsWith('.rip') && !hasCompileFlag) {
    // Check if file exists
    if (!existsSync(inputFile)) {
      console.error(`Error: File not found: ${inputFile}`);
      process.exit(1);
    }

    // Execute the script with Bun using our loader
    const loaderPath = join(__dirname, '../rip-loader.ts');

    // Get script arguments (everything after the input file)
    const inputFileIndex = args.indexOf(inputFile);
    const scriptArgs = args.slice(inputFileIndex + 1);

    try {
      execSync(`bun --preload ${loaderPath} ${inputFile} ${scriptArgs.join(' ')}`, {
        stdio: 'inherit'
      });
      process.exit(0);
    } catch (error) {
      process.exit(error.status || 1);
    }
  }

  let source;

  try {
    if (!inputFile) {
      // Read from stdin if no file specified (file descriptor 0)
      source = readFileSync(0, 'utf-8');
    } else {
      // Check if file exists first
      if (!existsSync(inputFile)) {
        console.error(`Error: File not found: ${inputFile}`);
        process.exit(1);
      }
      // Read source file
      source = readFileSync(inputFile, 'utf-8');
    }

    // Compile
    const compiler = new Compiler(options);
    const result = compiler.compile(source);

    // Determine if we should show compiled output
    // Show compiled JS if: -c flag, OR no debug flags (default mode), OR saving to file
    const shouldShowCompiled = showCompiled || (!showTokens && !showSExpr) || outputFile;

    // Output
    if (outputFile) {
      // Save to file
      writeFileSync(outputFile, result.code, 'utf-8');
      if (!options.quiet) {
        console.log(`Compiled to ${outputFile}`);
      }
    } else if (shouldShowCompiled) {
      // Show compiled output to stdout
      if (!options.quiet) {
        console.log(`// == JavaScript output by Rip ${VERSION} == //\n`);
      }
      console.log(result.code);
    }
  } catch (error) {
    console.error('Compilation Error:', error.message);
    if (error.stack) {
      console.error(error.stack);
    }
    process.exit(1);
  }
}

main();
