# Special Operators - Complete Guide

## Dammit Operator (`!`)

**Feature:** Call-and-await shorthand operator
**Status:** ‚úÖ Shipped in v0.3.4, Enhanced in v0.5.0
**Tests:** 29 tests, all passing
**Version:** 1.0.0

---

## What It Does

The **dammit operator (`!`)** is a trailing suffix that does TWO things:
1. **Calls the function** (even without parentheses)
2. **Awaits the result** (prepends `await`)

### Quick Examples

```coffeescript
# Simple call and await
result = fetchData!      # ‚Üí await fetchData()

# With arguments
user = getUser!(id)      # ‚Üí await getUser(id)

# Method calls
data = api.get!          # ‚Üí await api.get()

# In expressions
total = 5 + getValue!    # ‚Üí 5 + await getValue()
```

---

## Basic Usage

### 1. No Parens Needed

```coffeescript
# WITHOUT dammit - reference only
fn = loadConfig
typeof fn  # ‚Üí 'function'

# WITH dammit - calls immediately
config = loadConfig!  # ‚Üí await loadConfig()
```

**The `!` makes it a call, parens optional.**

### 2. With Arguments

```coffeescript
# ! signals await, parens provide args
result = fetchUser!(123)  # ‚Üí await fetchUser(123)

# Multiple args
data = query!('SELECT *', params)  # ‚Üí await query('SELECT *', params)
```

### 3. Method Calls

```coffeescript
# Property access + dammit
user = api.getUser!       # ‚Üí await api.getUser()

# With args
posts = api.getPosts!(userId)  # ‚Üí await api.getPosts(userId)

# Prototype
text = str::trim!         # ‚Üí await str.prototype.trim()
```

### 4. In Data Structures

```coffeescript
# Arrays - each element awaited
[user!, posts!, stats!]   # Each call awaited

# Expressions
x = compute!() + process!()  # Both awaited
```

---

## Comparison: Before & After

### Before (Explicit Await)

```coffeescript
# Verbose, repetitive
user = await db.findUser(id)
posts = await db.getPosts(user.id)
comments = await db.getComments(posts[0].id)
result = await buildResponse(comments)
```

### After (Dammit Operator)

```coffeescript
# Clean, concise
user = db.findUser!(id)
posts = db.getPosts!(user.id)
comments = db.getComments!(posts[0].id)
result = buildResponse!(comments)
```

**Benefit:** ~50% shorter, same clarity, **zero performance traps**

---

## Dual Sigil System

### At Call-Site: Dammit Operator (`!`)

**Forces await on function calls:**
```coffeescript
result = fetchData!      # ‚Üí await fetchData()
```

**Key behaviors:**
- Calls AND awaits
- Works on identifiers, methods, prototype access
- Functions containing `!` calls automatically become `async`

### At Definition-Site: Void Operator (`!`)

**Suppresses implicit returns (side-effect only functions):**
```coffeescript
def processItems!
  for item in items
    item.update()
  # ‚Üê Executes all statements, then returns undefined

# With explicit return (value stripped)
def validate!(x)
  return if x < 0     # ‚Üí Just "return" (no value)
  console.log "valid"
  # ‚Üê Executes console.log, then returns undefined
```

**Compiled output:**
```javascript
function processItems() {
  for (const item of items) { item.update(); }
  return;  // ‚Üê Explicit void return
}

function validate(x) {
  if (x < 0) return;  // ‚Üê Value stripped
  console.log("valid");
  return;  // ‚Üê Always undefined
}
```

**Works with all function types:**
```coffeescript
c! = (x) ->              # Void thin arrow
  x * 2                  # Executes but doesn't return value

process! = (data) =>     # Void fat arrow
  data.toUpperCase()     # Executes but returns undefined
```

---

## Restrictions

### ‚ùå Cannot Use in Declarations (Call-Site Only)

```coffeescript
# ERROR: Can't use ! in variable names
getData! = -> Promise.resolve(42)  # ‚ùå Error!

# ERROR: Can't use ! in function names (unless void function)
# (See void function syntax above)

# CORRECT: Use at call-site only
getData = -> Promise.resolve(42)   # ‚úì Define normally
result = getData!                  # ‚úì Use ! when calling
```

**Exception:** `!` at definition creates void function (no implicit returns)

**Rationale:** `!` at call-site is a call marker; `!` at definition means void.

---

## Why This Operator Exists

### The Problem with Implicit Await

We analyzed full implicit await (all async calls await by default) and found **critical problems:**

**‚ùå Performance Footgun:**
```coffeescript
# Easy to accidentally serialize parallel operations
user = fetchUser(id)     # waits 1 second
posts = fetchPosts(id)   # waits 1 second
stats = fetchStats(id)   # waits 1 second
# Total: 3 seconds instead of 1 second!
```

**‚ùå In Loops - Devastating:**
```coffeescript
# 100 items √ó 100ms each = 10 seconds instead of 100ms
for url in urls
  data = fetch(url)  # Serialized!
```

**‚ùå Ecosystem Mismatch:**
- JavaScript tooling expects explicit `await`
- Linters don't understand implicit await
- Type checkers can't infer await points
- Stack traces harder to debug

See [Design Decisions](#design-rationale) for full analysis.

### The Dammit Operator Solution

**‚úÖ 80% of ergonomic benefit**
**‚úÖ 0% of performance risk**

The dammit operator provides cleaner syntax WITHOUT the performance traps:

| Feature | Implicit Await | Dammit Operator | Explicit Await |
|---------|----------------|-----------------|----------------|
| **Syntax** | `fetchData()` | `fetchData!` | `await fetchData()` |
| **Chars saved** | -6 | -3 | 0 (baseline) |
| **Performance trap?** | ‚ùå Yes (easy) | ‚úÖ No (visible) | ‚úÖ No (visible) |
| **Ecosystem compat** | ‚ùå Poor | ‚úÖ Perfect | ‚úÖ Perfect |
| **Explicit?** | ‚ùå No | ‚úÖ Yes | ‚úÖ Yes |
| **Ready now?** | ‚ùå No | ‚úÖ Yes | ‚úÖ Yes |

---

## Usage Guidelines

### ‚úÖ When to Use `!`

**Sequential async code (most common case):**
```coffeescript
user = findUser!(id)
posts = getPosts!(user.id)
render!(user, posts)
```

**Simple async chains:**
```coffeescript
config = loadConfig!
db = connectDB!(config)
server = startServer!(db)
```

**API handlers (80% of async code):**
```coffeescript
get '/user/:id', (req) ->
  user = db.findUser!(req.params.id)
  posts = db.getPosts!(user.id)
  stats = db.getStats!(user.id)
  render('profile', {user, posts, stats})
```

### ‚ùå When NOT to Use `!`

**Parallel operations (use Promise.all):**
```coffeescript
# DON'T (serialized - slow):
a = fetch1!
b = fetch2!
c = fetch3!

# DO (parallel - fast):
[a, b, c] = await Promise.all([fetch1(), fetch2(), fetch3()])
```

**Function references (when you don't want to call):**
```coffeescript
# DON'T:
callback = processData!  # Calls it immediately!

# DO:
callback = processData   # Just a reference
```

**In loops (unless you mean it):**
```coffeescript
# DON'T (probably serialized):
for item in items
  result = process!(item)  # Each awaits before next!

# DO (parallel with comprehension):
results = await Promise.all (process(item) for item in items)
```

---

## How It Works

### Lexer (src/lexer.js)

**Line 1749:** Identifier regex already allowed trailing `!`
```javascript
IDENTIFIER = /^(?!\d)((?:(?!\s)[$\w\x7f-\uffff])+!?)([^\n\S]*:(?!:))?/;
//                                                  ^^
//                                          optional trailing !
```

**Lines 426-442:** Detect `!`, add metadata, strip from name
```javascript
if (id.length > 1 && id.endsWith('!')) {
  tokenData.await = true;  // Mark for await
  id = id.slice(0, -1);    // Strip ! from identifier name
}
```

### Parser

No changes needed! Grammar preserves String objects with metadata.

### Codegen (src/codegen.js)

**Lines 267-277:** Bare identifier with `!`
```javascript
if (sexpr instanceof String && sexpr.await === true) {
  const cleanName = sexpr.valueOf();
  return `await ${cleanName}()`;  // Add call + await
}
```

**Lines 936-940:** Property access with `!`
```javascript
if (prop instanceof String && prop.await === true) {
  const cleanProp = prop.valueOf();
  return `await ${base}.${cleanProp}()`;
}
```

**Lines 3183-3190:** Function call with `!`
```javascript
const needsAwait = headAwaitMetadata === true;
const callStr = `${calleeName}(${args})`;
return needsAwait ? `await ${callStr}` : callStr;
```

**Lines 4180-4215:** Async detection
```javascript
containsAwait(sexpr) {
  // Check for dammit operator
  if (sexpr instanceof String && sexpr.await === true) {
    return true;  // Contains await
  }
  // ... also checks explicit await nodes
}
```

---

## Design Rationale

### Why Not Full Implicit Await?

We thoroughly analyzed implicit await (all async calls await by default). Here's why we rejected it:

**1. Performance Footgun (Critical)** üî¥
- Easy to serialize parallel work accidentally
- Devastating in loops (10x slowdowns)
- Hard to spot in code review

**2. Ecosystem Mismatch**
- JS tooling expects explicit `await`
- TypeScript can't infer await points
- Breaks existing patterns

**3. Mental Model Confusion**
- Fights 10+ years of industry training
- Mixing contexts is confusing
- Callbacks become ambiguous

See full analysis in `docs-ORIG/ASYNC.md` for complete reasoning.

### Why Dammit Operator Works

**Advantages over full implicit await:**
- ‚úÖ **Explicit** - Visual signal at every async call
- ‚úÖ **No performance traps** - Each await is marked
- ‚úÖ **Backwards compatible** - Purely additive feature
- ‚úÖ **No ecosystem friction** - Generates standard `async/await`
- ‚úÖ **Clear intent** - `!` says "I mean to await this"

**Better than bare `await`:**
- ‚úÖ **Shorter** - `fetchData!` vs `await fetchData()`
- ‚úÖ **Cleaner** - Less noise in sequential async code
- ‚úÖ **Ruby-inspired** - Familiar from `method!` convention
- ‚úÖ **Dual purpose** - Also calls without parens

---

## Future: Punt Operator (`&`)

The infrastructure is ready for the `&` operator to prevent await:

```coffeescript
# Future: Implicit await mode
result = fetchData()      # awaits by default (when mode enabled)
promise = &fetchData()    # opt-out with &
forced = fetchData!       # explicit await even in explicit mode

# Interaction:
fetchData!    # ‚Üí await fetchData() (dammit forces)
&fetchData    # ‚Üí fetchData() (punt prevents)
&fetchData!   # ‚Üí fetchData() (punt wins, but ! still calls)
```

**Decision:** We'll evaluate punt operator based on dammit usage and feedback.

**Status:** Ready but not implemented (lexer/codegen prepared, commented out)

---

## Implementation Summary

### Code Changes

**Lexer (`src/lexer.js`):**
- Regex already supported `!` suffix on identifiers (line 1749)
- Added `.await = true` metadata to token data
- Strips `!` from identifier name
- ~15 lines added

**Parser:**
- No changes (String objects flow through)

**Codegen (`src/codegen.js`):**
- Detects `.await` property on String objects
- Converts `identifier!` ‚Üí `await identifier()`
- Handles bare identifiers, calls with args, method calls, prototype access
- Updated `containsAwait()` to detect dammit operators
- Auto-marks functions as `async` when they contain `!` calls
- ~90 lines added

**Tests (`test/rip/async.rip`):**
- 29 comprehensive tests
- Execution tests (basic, args, methods, arrays, expressions)
- Code generation tests
- Validation tests (errors on invalid usage)
- All passing

### Metadata Flow

1. **Lexer:** Sees `fetchData!` token
   - Matches `IDENTIFIER` regex (includes `!`)
   - Creates String object with `.await = true`
   - Strips `!` from identifier name
   - Returns token `["IDENTIFIER", String("fetchData")]` where `fetchData.await === true`

2. **Parser:** Preserves String objects
   - Grammar returns the String object as-is
   - S-expression contains String objects with metadata intact

3. **Codegen:** Checks `.await` property
   - Before converting to primitive, saves `.await` value
   - If `.await === true`, wraps with `await` and adds `()`
   - Generates clean JavaScript

### Why This Design

‚úÖ **Clean separation** - Lexer marks, codegen acts
‚úÖ **Extensible** - Ready for `&` with minimal changes
‚úÖ **Type-safe** - Uses existing String metadata pattern
‚úÖ **Maintainable** - Clear flow, well-documented
‚úÖ **Zero runtime overhead** - Pure syntactic sugar

---

## Performance

**No compilation overhead:**
- Lexer already scanned for `!` (regex had it)
- Metadata is free (existing String object pattern)
- Codegen just checks a boolean property
- Generated code is standard `async/await`

**Runtime:**
- Identical to writing `await` manually
- No extra function calls
- No wrappers
- Pure syntactic sugar

**Generated code quality:**
```coffeescript
# Input
user = getUser!(id)
posts = getPosts!(user.id)

# Output
async function() {
  let user, posts;
  user = await getUser(id);
  posts = await getPosts(user.id);
}
```

Clean, readable, standard JavaScript!

---

## Real-World Examples

### API Handler Pattern

**Before:**
```coffeescript
get '/user/:id', (req) ->
  user = await db.findUser(req.params.id)
  posts = await db.getPosts(user.id)
  stats = await db.getStats(user.id)
  await render('profile', {user, posts, stats})
```

**After:**
```coffeescript
get '/user/:id', (req) ->
  user = db.findUser!(req.params.id)
  posts = db.getPosts!(user.id)
  stats = db.getStats!(user.id)
  render!('profile', {user, posts, stats})
```

### Data Pipeline

**Before:**
```coffeescript
data = await loadData()
validated = await validate(data)
transformed = await transform(validated)
await save(transformed)
```

**After:**
```coffeescript
data = loadData!
validated = validate!(data)
transformed = transform!(validated)
save!(transformed)
```

### Error Handling

```coffeescript
try
  user = findUser!(id)      # Error throws HERE
  posts = getPosts!(user)   # Not here if findUser failed
catch err
  handleError(err)
```

Works naturally with try/catch at call sites!

---

## Best Practices

### ‚úÖ DO: Sequential Operations

```coffeescript
# Clear, clean, explicit
config = loadConfig!
db = connectDB!(config)
server = startServer!(db)
```

### ‚úÖ DO: Error Boundaries

```coffeescript
# Natural error handling
try
  result = riskyOperation!
  process!(result)
catch error
  logError!(error)
```

### ‚ùå DON'T: Parallel Operations

```coffeescript
# BAD: Serialized (slow)
a = fetch1!
b = fetch2!
c = fetch3!

# GOOD: Parallel (fast)
[a, b, c] = await Promise.all([
  fetch1()
  fetch2()
  fetch3()
])
```

### ‚ùå DON'T: In Tight Loops

```coffeescript
# BAD: Serializes every iteration
for item in items
  result = process!(item)  # Each awaits!

# GOOD: Parallel processing
results = await Promise.all (process(item) for item in items)
```

---

## Testing

### Comprehensive Test Suite

**29 tests in `test/rip/async.rip`:**

**Execution tests:**
- Basic dammit operator (bare identifier)
- With parameters
- Method calls (property access)
- Multiple calls in sequence
- No parens (proves ! calls the function)
- Redundant parens (fetchData!() works)
- Reference vs call comparison
- Actually calls (side effects verified)
- In expressions (arithmetic)
- In arrays (multiple awaits)

**Code generation tests:**
- Bare identifier compilation
- Method call compilation
- Auto-async detection

**Validation tests:**
- Error on ! in variable declaration
- Error on ! in function name (unless void function)

**All tests passing!** ‚úÖ

---

## Void Function Tests

**10 tests in `test/rip/functions.rip`:**

- Void function with def
- Void function with thin arrow
- Void function with fat arrow
- Explicit return (value stripped)
- Multi-statement body
- Side effects preserved
- Code generation validation

---

## Comparison with Other Languages

### Ruby
```ruby
# Exclamation convention (mutating methods)
str.upcase!    # Mutates in place
```

### Rip
```coffeescript
# Exclamation for await (non-mutating, just async)
result = fetchData!  # Awaits result
```

**Inspiration:** Ruby's `!` convention, but adapted for async/await

### JavaScript (Standard)
```javascript
const result = await fetchData();
```

### Rip
```coffeescript
result = fetchData!  # 3 fewer characters, same meaning
```

---

## Why Ship This?

### Pragmatic Decision

We wanted cleaner async syntax but found full implicit await has critical flaws (see ASYNC.md analysis).

**The dammit operator gives us:**
- ‚úÖ Cleaner code (50% less await noise)
- ‚úÖ Explicit semantics (every await visible)
- ‚úÖ No performance traps (can't accidentally serialize)
- ‚úÖ Ecosystem compatibility (generates standard async/await)
- ‚úÖ Future-proof (enables punt operator later)

### Best of Both Worlds

| Aspect | Dammit Wins |
|--------|-------------|
| **vs. bare await** | Shorter, cleaner syntax |
| **vs. implicit await** | Explicit, safe, no traps |
| **vs. promises** | Natural error handling |

---

## Error Messages

**Invalid usage produces clear errors:**

```coffeescript
# Error: Can't use ! in variable declaration
getData! = -> 42
# Error: Cannot use ! sigil in variable declaration 'getData'.
#        Sigils are only for call-sites.

# Exception: Void functions are allowed
def process!()  # ‚úì OK - void function syntax
  doWork()
```

---

## Roadmap

### v0.3.4
- ‚úÖ Dammit operator (`!`) implemented
- ‚úÖ Basic call-and-await functionality

### v0.5.0 (Current)
- ‚úÖ Void function syntax (`!` at definition)
- ‚úÖ Call-site validation
- ‚úÖ Enhanced error messages
- ‚úÖ Comprehensive tests (29 total)
- ‚úÖ Documentation complete

### Future Considerations
- üìã Punt operator (`&`) - if community wants it
- üìã Implicit await mode - experimental branch only
- üìã Linting for serial await patterns
- üìã Performance hints in tooling

---

## Summary

**The dammit operator is production-ready:**

‚úÖ **Syntax:** `fetchData!` ‚Üí `await fetchData()`
‚úÖ **Dual purpose:** Calls AND awaits
‚úÖ **Safe:** Every await is explicit
‚úÖ **Fast:** No performance traps
‚úÖ **Clean:** 50% less syntax noise
‚úÖ **Compatible:** Standard JavaScript output
‚úÖ **Tested:** 29 comprehensive tests
‚úÖ **Documented:** Complete guide and examples

**Recommendation:** Use for sequential async code. Avoid in loops and parallel operations.

**See Also:**
- [ASYNC.md](../docs-ORIG/ASYNC.md) - Full implicit await analysis
- [COMPREHENSIONS.md](COMPREHENSIONS.md) - Context-aware code generation
- [README.md](../README-ORIG.md) - User guide

---

**The dammit operator: Async syntax that doesn't compromise.** ‚ö°
